/**\n * WebSocket Client Manager\n * Handles client-side WebSocket connections with automatic reconnection and message queuing\n */\n\ninterface WebSocketMessage {\n  type: string;\n  data?: any;\n  target?: string | string[];\n  timestamp?: number;\n  messageId?: string;\n}\n\ninterface ConnectionOptions {\n  url?: string;\n  token?: string;\n  autoReconnect?: boolean;\n  maxReconnectAttempts?: number;\n  reconnectDelay?: number;\n  heartbeatInterval?: number;\n}\n\ninterface ConnectionStatus {\n  isConnected: boolean;\n  isConnecting: boolean;\n  isReconnecting: boolean;\n  lastConnected?: Date;\n  reconnectAttempts: number;\n  error?: string;\n}\n\ntype EventHandler = (data: any) => void;\ntype ConnectionEventHandler = (status: ConnectionStatus) => void;\n\nexport class WebSocketClient {\n  private ws: WebSocket | null = null;\n  private url: string;\n  private token: string | null = null;\n  private options: Required<ConnectionOptions>;\n  private status: ConnectionStatus;\n  private eventHandlers: Map<string, EventHandler[]> = new Map();\n  private connectionHandlers: ConnectionEventHandler[] = [];\n  private messageQueue: WebSocketMessage[] = [];\n  private reconnectTimeout: NodeJS.Timeout | null = null;\n  private heartbeatInterval: NodeJS.Timeout | null = null;\n  private subscriptions: Set<string> = new Set();\n  private metadata: Record<string, any> = {};\n\n  constructor(options: ConnectionOptions = {}) {\n    this.url = options.url || this.getDefaultWebSocketUrl();\n    this.token = options.token || this.getStoredToken();\n    \n    this.options = {\n      url: this.url,\n      token: this.token,\n      autoReconnect: options.autoReconnect ?? true,\n      maxReconnectAttempts: options.maxReconnectAttempts ?? 5,\n      reconnectDelay: options.reconnectDelay ?? 1000,\n      heartbeatInterval: options.heartbeatInterval ?? 30000\n    };\n\n    this.status = {\n      isConnected: false,\n      isConnecting: false,\n      isReconnecting: false,\n      reconnectAttempts: 0\n    };\n  }\n\n  /**\n   * Connect to WebSocket server\n   */\n  async connect(token?: string): Promise<boolean> {\n    if (this.status.isConnected || this.status.isConnecting) {\n      console.warn('‚ö†Ô∏è WebSocket already connected or connecting');\n      return this.status.isConnected;\n    }\n\n    if (token) {\n      this.token = token;\n      this.options.token = token;\n    }\n\n    if (!this.token) {\n      const error = 'No authentication token available';\n      this.updateStatus({ error });\n      throw new Error(error);\n    }\n\n    return new Promise((resolve, reject) => {\n      try {\n        this.updateStatus({ isConnecting: true, error: undefined });\n        \n        const wsUrl = `${this.url}?token=${encodeURIComponent(this.token)}`;\n        this.ws = new WebSocket(wsUrl);\n\n        const connectTimeout = setTimeout(() => {\n          if (this.ws && this.ws.readyState === WebSocket.CONNECTING) {\n            this.ws.close();\n            const error = 'Connection timeout';\n            this.updateStatus({ isConnecting: false, error });\n            reject(new Error(error));\n          }\n        }, 10000); // 10 second timeout\n\n        this.ws.onopen = () => {\n          clearTimeout(connectTimeout);\n          console.log('üîó WebSocket connected');\n          \n          this.updateStatus({\n            isConnected: true,\n            isConnecting: false,\n            isReconnecting: false,\n            lastConnected: new Date(),\n            reconnectAttempts: 0,\n            error: undefined\n          });\n\n          this.startHeartbeat();\n          this.processMessageQueue();\n          this.resubscribeToEvents();\n          \n          resolve(true);\n        };\n\n        this.ws.onmessage = (event) => {\n          this.handleMessage(event.data);\n        };\n\n        this.ws.onclose = (event) => {\n          clearTimeout(connectTimeout);\n          this.handleDisconnection(event.code, event.reason);\n          \n          if (this.status.isConnecting) {\n            const error = `Connection failed: ${event.reason || 'Unknown error'}`;\n            this.updateStatus({ isConnecting: false, error });\n            reject(new Error(error));\n          }\n        };\n\n        this.ws.onerror = (error) => {\n          clearTimeout(connectTimeout);\n          console.error('‚ùå WebSocket error:', error);\n          \n          const errorMessage = 'WebSocket connection error';\n          this.updateStatus({ error: errorMessage });\n          \n          if (this.status.isConnecting) {\n            this.updateStatus({ isConnecting: false });\n            reject(new Error(errorMessage));\n          }\n        };\n\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Failed to create WebSocket connection';\n        this.updateStatus({ isConnecting: false, error: errorMessage });\n        reject(new Error(errorMessage));\n      }\n    });\n  }\n\n  /**\n   * Disconnect from WebSocket server\n   */\n  disconnect(): void {\n    console.log('üîå Disconnecting WebSocket...');\n    \n    this.options.autoReconnect = false; // Disable auto-reconnect\n    \n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    \n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n\n    if (this.ws) {\n      this.ws.close(1000, 'Client disconnect');\n      this.ws = null;\n    }\n\n    this.updateStatus({\n      isConnected: false,\n      isConnecting: false,\n      isReconnecting: false\n    });\n  }\n\n  /**\n   * Send message to server\n   */\n  send(message: WebSocketMessage): boolean {\n    if (!this.status.isConnected || !this.ws) {\n      // Queue message for later if not connected\n      this.messageQueue.push({\n        ...message,\n        timestamp: Date.now(),\n        messageId: message.messageId || this.generateMessageId()\n      });\n      \n      console.log(`üì§ Message queued (not connected): ${message.type}`);\n      return false;\n    }\n\n    try {\n      const messageWithMetadata = {\n        ...message,\n        timestamp: Date.now(),\n        messageId: message.messageId || this.generateMessageId()\n      };\n      \n      this.ws.send(JSON.stringify(messageWithMetadata));\n      console.log(`üì§ Message sent: ${message.type}`);\n      return true;\n    } catch (error) {\n      console.error('‚ùå Failed to send message:', error);\n      \n      // Queue message for retry\n      this.messageQueue.push(message);\n      return false;\n    }\n  }\n\n  /**\n   * Subscribe to server events\n   */\n  subscribe(subscription: string): void {\n    this.subscriptions.add(subscription);\n    \n    this.send({\n      type: 'subscribe',\n      data: { subscription }\n    });\n    \n    console.log(`üì° Subscribed to: ${subscription}`);\n  }\n\n  /**\n   * Unsubscribe from server events\n   */\n  unsubscribe(subscription: string): void {\n    this.subscriptions.delete(subscription);\n    \n    this.send({\n      type: 'unsubscribe',\n      data: { subscription }\n    });\n    \n    console.log(`üì° Unsubscribed from: ${subscription}`);\n  }\n\n  /**\n   * Broadcast message to other clients\n   */\n  broadcast(data: any, target?: string | string[], subscription?: string): void {\n    this.send({\n      type: 'broadcast',\n      data: {\n        data,\n        target,\n        subscription\n      }\n    });\n  }\n\n  /**\n   * Update client metadata\n   */\n  updateMetadata(metadata: Record<string, any>): void {\n    this.metadata = { ...this.metadata, ...metadata };\n    \n    this.send({\n      type: 'update_metadata',\n      data: { metadata }\n    });\n  }\n\n  /**\n   * Get connection info from server\n   */\n  getConnectionInfo(): void {\n    this.send({\n      type: 'get_info'\n    });\n  }\n\n  /**\n   * Add event handler\n   */\n  on(event: string, handler: EventHandler): void {\n    if (!this.eventHandlers.has(event)) {\n      this.eventHandlers.set(event, []);\n    }\n    this.eventHandlers.get(event)!.push(handler);\n  }\n\n  /**\n   * Remove event handler\n   */\n  off(event: string, handler: EventHandler): void {\n    const handlers = this.eventHandlers.get(event);\n    if (handlers) {\n      const index = handlers.indexOf(handler);\n      if (index > -1) {\n        handlers.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Add connection status handler\n   */\n  onConnectionChange(handler: ConnectionEventHandler): void {\n    this.connectionHandlers.push(handler);\n  }\n\n  /**\n   * Remove connection status handler\n   */\n  offConnectionChange(handler: ConnectionEventHandler): void {\n    const index = this.connectionHandlers.indexOf(handler);\n    if (index > -1) {\n      this.connectionHandlers.splice(index, 1);\n    }\n  }\n\n  /**\n   * Get current connection status\n   */\n  getStatus(): ConnectionStatus {\n    return { ...this.status };\n  }\n\n  /**\n   * Check if connected\n   */\n  isConnected(): boolean {\n    return this.status.isConnected;\n  }\n\n  /**\n   * Handle incoming message\n   */\n  private handleMessage(data: string): void {\n    try {\n      const message: WebSocketMessage = JSON.parse(data);\n      \n      console.log(`üì® Message received: ${message.type}`);\n      \n      // Handle system messages\n      switch (message.type) {\n        case 'pong':\n          // Heartbeat response - no action needed\n          break;\n          \n        case 'connection_established':\n          console.log('‚úÖ Connection established:', message.data);\n          break;\n          \n        case 'subscribed':\n          console.log(`üì° Subscription confirmed: ${message.data?.subscription}`);\n          break;\n          \n        case 'unsubscribed':\n          console.log(`üì° Unsubscription confirmed: ${message.data?.subscription}`);\n          break;\n          \n        case 'error':\n          console.error('‚ùå Server error:', message.data);\n          this.emit('error', message.data);\n          break;\n          \n        default:\n          // Emit custom events\n          this.emit(message.type, message.data);\n          break;\n      }\n      \n    } catch (error) {\n      console.error('‚ùå Failed to parse WebSocket message:', error);\n    }\n  }\n\n  /**\n   * Handle disconnection\n   */\n  private handleDisconnection(code: number, reason: string): void {\n    console.log(`üîå WebSocket disconnected - Code: ${code}, Reason: ${reason}`);\n    \n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n\n    const wasConnected = this.status.isConnected;\n    \n    this.updateStatus({\n      isConnected: false,\n      isConnecting: false\n    });\n\n    // Attempt reconnection if enabled and was previously connected\n    if (this.options.autoReconnect && wasConnected && code !== 1000) {\n      this.attemptReconnection();\n    }\n  }\n\n  /**\n   * Attempt to reconnect\n   */\n  private attemptReconnection(): void {\n    if (this.status.reconnectAttempts >= this.options.maxReconnectAttempts) {\n      console.error('‚ùå Max reconnection attempts reached');\n      this.updateStatus({ \n        isReconnecting: false,\n        error: 'Max reconnection attempts reached'\n      });\n      return;\n    }\n\n    const delay = this.options.reconnectDelay * Math.pow(2, this.status.reconnectAttempts);\n    \n    this.updateStatus({ \n      isReconnecting: true,\n      reconnectAttempts: this.status.reconnectAttempts + 1\n    });\n    \n    console.log(`üîÑ Attempting reconnection ${this.status.reconnectAttempts}/${this.options.maxReconnectAttempts} in ${delay}ms`);\n    \n    this.reconnectTimeout = setTimeout(async () => {\n      try {\n        await this.connect();\n      } catch (error) {\n        console.error('‚ùå Reconnection failed:', error);\n        this.attemptReconnection(); // Try again\n      }\n    }, delay);\n  }\n\n  /**\n   * Start heartbeat\n   */\n  private startHeartbeat(): void {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n    }\n    \n    this.heartbeatInterval = setInterval(() => {\n      if (this.status.isConnected) {\n        this.send({ type: 'ping' });\n      }\n    }, this.options.heartbeatInterval);\n  }\n\n  /**\n   * Process queued messages\n   */\n  private processMessageQueue(): void {\n    if (this.messageQueue.length === 0) return;\n    \n    console.log(`üì§ Processing ${this.messageQueue.length} queued messages`);\n    \n    const messages = [...this.messageQueue];\n    this.messageQueue = [];\n    \n    messages.forEach(message => {\n      this.send(message);\n    });\n  }\n\n  /**\n   * Resubscribe to events after reconnection\n   */\n  private resubscribeToEvents(): void {\n    this.subscriptions.forEach(subscription => {\n      this.send({\n        type: 'subscribe',\n        data: { subscription }\n      });\n    });\n    \n    // Restore metadata\n    if (Object.keys(this.metadata).length > 0) {\n      this.send({\n        type: 'update_metadata',\n        data: { metadata: this.metadata }\n      });\n    }\n  }\n\n  /**\n   * Update connection status\n   */\n  private updateStatus(updates: Partial<ConnectionStatus>): void {\n    this.status = { ...this.status, ...updates };\n    \n    // Notify connection handlers\n    this.connectionHandlers.forEach(handler => {\n      try {\n        handler(this.status);\n      } catch (error) {\n        console.error('‚ùå Error in connection handler:', error);\n      }\n    });\n  }\n\n  /**\n   * Emit event to handlers\n   */\n  private emit(event: string, data: any): void {\n    const handlers = this.eventHandlers.get(event);\n    if (handlers) {\n      handlers.forEach(handler => {\n        try {\n          handler(data);\n        } catch (error) {\n          console.error(`‚ùå Error in event handler for ${event}:`, error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Generate unique message ID\n   */\n  private generateMessageId(): string {\n    return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Get default WebSocket URL\n   */\n  private getDefaultWebSocketUrl(): string {\n    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n    const host = window.location.host;\n    return `${protocol}//${host}/ws`;\n  }\n\n  /**\n   * Get stored authentication token\n   */\n  private getStoredToken(): string | null {\n    return localStorage.getItem('auth_token');\n  }\n}\n\n// Singleton instance\nlet wsClient: WebSocketClient | null = null;\n\nexport const getWebSocketClient = (options?: ConnectionOptions): WebSocketClient => {\n  if (!wsClient) {\n    wsClient = new WebSocketClient(options);\n  }\n  return wsClient;\n};\n\nexport const initializeWebSocketClient = async (options?: ConnectionOptions): Promise<WebSocketClient> => {\n  const client = getWebSocketClient(options);\n  await client.connect();\n  return client;\n};\n\nexport default WebSocketClient;"