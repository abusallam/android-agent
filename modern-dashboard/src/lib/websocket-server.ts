/**\n * WebSocket Server Implementation\n * Handles real-time communication with authentication and connection pooling\n */\n\nimport { WebSocketServer, WebSocket } from 'ws';\nimport { IncomingMessage } from 'http';\nimport jwt from 'jsonwebtoken';\nimport { v4 as uuidv4 } from 'uuid';\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-jwt-secret';\n\ninterface AuthenticatedUser {\n  id: string;\n  username: string;\n  role: string;\n}\n\ninterface WebSocketConnection {\n  id: string;\n  ws: WebSocket;\n  user: AuthenticatedUser;\n  lastPing: number;\n  subscriptions: Set<string>;\n  metadata: Record<string, any>;\n}\n\ninterface WebSocketMessage {\n  type: string;\n  data?: any;\n  target?: string | string[];\n  timestamp?: number;\n  messageId?: string;\n}\n\ninterface BroadcastOptions {\n  excludeConnection?: string;\n  includeRoles?: string[];\n  excludeRoles?: string[];\n  targetUsers?: string[];\n  subscription?: string;\n}\n\nexport class WebSocketManager {\n  private wss: WebSocketServer | null = null;\n  private connections: Map<string, WebSocketConnection> = new Map();\n  private userConnections: Map<string, Set<string>> = new Map();\n  private subscriptions: Map<string, Set<string>> = new Map();\n  private messageHandlers: Map<string, Function> = new Map();\n  private heartbeatInterval: NodeJS.Timeout | null = null;\n  private isRunning = false;\n\n  constructor(private port: number = 8080) {\n    this.setupMessageHandlers();\n  }\n\n  /**\n   * Start the WebSocket server\n   */\n  start(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      try {\n        this.wss = new WebSocketServer({ \n          port: this.port,\n          perMessageDeflate: {\n            zlibDeflateOptions: {\n              level: 3,\n              chunkSize: 1024,\n            },\n            threshold: 1024,\n            concurrencyLimit: 10,\n          }\n        });\n\n        this.wss.on('connection', this.handleConnection.bind(this));\n        this.wss.on('error', (error) => {\n          console.error('‚ùå WebSocket server error:', error);\n          reject(error);\n        });\n\n        this.wss.on('listening', () => {\n          console.log(`üîå WebSocket server listening on port ${this.port}`);\n          this.isRunning = true;\n          this.startHeartbeat();\n          resolve();\n        });\n\n      } catch (error) {\n        console.error('‚ùå Failed to start WebSocket server:', error);\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Stop the WebSocket server\n   */\n  async stop(): Promise<void> {\n    return new Promise((resolve) => {\n      this.isRunning = false;\n      \n      if (this.heartbeatInterval) {\n        clearInterval(this.heartbeatInterval);\n        this.heartbeatInterval = null;\n      }\n\n      // Close all connections\n      this.connections.forEach((connection) => {\n        connection.ws.close(1000, 'Server shutting down');\n      });\n      \n      this.connections.clear();\n      this.userConnections.clear();\n      this.subscriptions.clear();\n\n      if (this.wss) {\n        this.wss.close(() => {\n          console.log('üîå WebSocket server stopped');\n          resolve();\n        });\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  /**\n   * Handle new WebSocket connection\n   */\n  private async handleConnection(ws: WebSocket, request: IncomingMessage): Promise<void> {\n    const connectionId = uuidv4();\n    \n    try {\n      // Extract token from query string or headers\n      const url = new URL(request.url || '', `http://${request.headers.host}`);\n      const token = url.searchParams.get('token') || request.headers.authorization?.replace('Bearer ', '');\n      \n      if (!token) {\n        ws.close(1008, 'Authentication token required');\n        return;\n      }\n\n      // Verify JWT token\n      const decoded = jwt.verify(token, JWT_SECRET) as any;\n      const user: AuthenticatedUser = {\n        id: decoded.id || decoded.userId,\n        username: decoded.username,\n        role: decoded.role || 'USER'\n      };\n\n      // Create connection object\n      const connection: WebSocketConnection = {\n        id: connectionId,\n        ws,\n        user,\n        lastPing: Date.now(),\n        subscriptions: new Set(),\n        metadata: {}\n      };\n\n      // Store connection\n      this.connections.set(connectionId, connection);\n      \n      // Track user connections\n      if (!this.userConnections.has(user.id)) {\n        this.userConnections.set(user.id, new Set());\n      }\n      this.userConnections.get(user.id)!.add(connectionId);\n\n      console.log(`üîó WebSocket connection established: ${user.username} (${connectionId})`);\n\n      // Set up connection event handlers\n      ws.on('message', (data) => this.handleMessage(connectionId, data));\n      ws.on('close', (code, reason) => this.handleDisconnection(connectionId, code, reason));\n      ws.on('error', (error) => this.handleConnectionError(connectionId, error));\n      ws.on('pong', () => this.handlePong(connectionId));\n\n      // Send welcome message\n      this.sendToConnection(connectionId, {\n        type: 'connection_established',\n        data: {\n          connectionId,\n          user: {\n            id: user.id,\n            username: user.username,\n            role: user.role\n          },\n          serverTime: new Date().toISOString()\n        }\n      });\n\n      // Notify other connections about new user\n      this.broadcast({\n        type: 'user_connected',\n        data: {\n          userId: user.id,\n          username: user.username,\n          role: user.role\n        }\n      }, { excludeConnection: connectionId });\n\n    } catch (error) {\n      console.error(`‚ùå WebSocket authentication failed for ${connectionId}:`, error);\n      ws.close(1008, 'Authentication failed');\n    }\n  }\n\n  /**\n   * Handle incoming WebSocket message\n   */\n  private handleMessage(connectionId: string, data: Buffer | string): void {\n    const connection = this.connections.get(connectionId);\n    if (!connection) return;\n\n    try {\n      const message: WebSocketMessage = JSON.parse(data.toString());\n      message.timestamp = Date.now();\n      message.messageId = message.messageId || uuidv4();\n\n      console.log(`üì® WebSocket message from ${connection.user.username}: ${message.type}`);\n\n      // Handle message based on type\n      const handler = this.messageHandlers.get(message.type);\n      if (handler) {\n        handler(connectionId, message, connection);\n      } else {\n        console.warn(`‚ö†Ô∏è Unknown message type: ${message.type}`);\n        this.sendToConnection(connectionId, {\n          type: 'error',\n          data: {\n            message: `Unknown message type: ${message.type}`,\n            originalMessageId: message.messageId\n          }\n        });\n      }\n\n    } catch (error) {\n      console.error(`‚ùå Failed to parse WebSocket message from ${connectionId}:`, error);\n      this.sendToConnection(connectionId, {\n        type: 'error',\n        data: {\n          message: 'Invalid message format',\n          error: error instanceof Error ? error.message : 'Unknown error'\n        }\n      });\n    }\n  }\n\n  /**\n   * Handle WebSocket disconnection\n   */\n  private handleDisconnection(connectionId: string, code: number, reason: Buffer): void {\n    const connection = this.connections.get(connectionId);\n    if (!connection) return;\n\n    console.log(`üîå WebSocket disconnection: ${connection.user.username} (${connectionId}) - Code: ${code}`);\n\n    // Remove from user connections\n    const userConnections = this.userConnections.get(connection.user.id);\n    if (userConnections) {\n      userConnections.delete(connectionId);\n      if (userConnections.size === 0) {\n        this.userConnections.delete(connection.user.id);\n      }\n    }\n\n    // Remove from subscriptions\n    connection.subscriptions.forEach(subscription => {\n      const subscribers = this.subscriptions.get(subscription);\n      if (subscribers) {\n        subscribers.delete(connectionId);\n        if (subscribers.size === 0) {\n          this.subscriptions.delete(subscription);\n        }\n      }\n    });\n\n    // Remove connection\n    this.connections.delete(connectionId);\n\n    // Notify other connections about user disconnection\n    if (!this.userConnections.has(connection.user.id)) {\n      this.broadcast({\n        type: 'user_disconnected',\n        data: {\n          userId: connection.user.id,\n          username: connection.user.username\n        }\n      });\n    }\n  }\n\n  /**\n   * Handle WebSocket connection error\n   */\n  private handleConnectionError(connectionId: string, error: Error): void {\n    const connection = this.connections.get(connectionId);\n    console.error(`‚ùå WebSocket connection error for ${connection?.user.username || connectionId}:`, error);\n  }\n\n  /**\n   * Handle pong response\n   */\n  private handlePong(connectionId: string): void {\n    const connection = this.connections.get(connectionId);\n    if (connection) {\n      connection.lastPing = Date.now();\n    }\n  }\n\n  /**\n   * Set up message handlers\n   */\n  private setupMessageHandlers(): void {\n    // Ping handler\n    this.messageHandlers.set('ping', (connectionId: string, message: WebSocketMessage) => {\n      this.sendToConnection(connectionId, {\n        type: 'pong',\n        data: { timestamp: Date.now() },\n        messageId: message.messageId\n      });\n    });\n\n    // Subscribe to events\n    this.messageHandlers.set('subscribe', (connectionId: string, message: WebSocketMessage, connection: WebSocketConnection) => {\n      const { subscription } = message.data || {};\n      if (!subscription) {\n        this.sendToConnection(connectionId, {\n          type: 'error',\n          data: { message: 'Subscription name required' }\n        });\n        return;\n      }\n\n      connection.subscriptions.add(subscription);\n      \n      if (!this.subscriptions.has(subscription)) {\n        this.subscriptions.set(subscription, new Set());\n      }\n      this.subscriptions.get(subscription)!.add(connectionId);\n\n      this.sendToConnection(connectionId, {\n        type: 'subscribed',\n        data: { subscription }\n      });\n\n      console.log(`üì° ${connection.user.username} subscribed to ${subscription}`);\n    });\n\n    // Unsubscribe from events\n    this.messageHandlers.set('unsubscribe', (connectionId: string, message: WebSocketMessage, connection: WebSocketConnection) => {\n      const { subscription } = message.data || {};\n      if (!subscription) return;\n\n      connection.subscriptions.delete(subscription);\n      \n      const subscribers = this.subscriptions.get(subscription);\n      if (subscribers) {\n        subscribers.delete(connectionId);\n        if (subscribers.size === 0) {\n          this.subscriptions.delete(subscription);\n        }\n      }\n\n      this.sendToConnection(connectionId, {\n        type: 'unsubscribed',\n        data: { subscription }\n      });\n\n      console.log(`üì° ${connection.user.username} unsubscribed from ${subscription}`);\n    });\n\n    // Broadcast message to other users\n    this.messageHandlers.set('broadcast', (connectionId: string, message: WebSocketMessage, connection: WebSocketConnection) => {\n      const { data, target, subscription } = message.data || {};\n      \n      this.broadcast({\n        type: 'broadcast_message',\n        data: {\n          from: {\n            id: connection.user.id,\n            username: connection.user.username\n          },\n          message: data,\n          timestamp: Date.now()\n        }\n      }, {\n        excludeConnection: connectionId,\n        targetUsers: target,\n        subscription\n      });\n    });\n\n    // Update user metadata\n    this.messageHandlers.set('update_metadata', (connectionId: string, message: WebSocketMessage, connection: WebSocketConnection) => {\n      const { metadata } = message.data || {};\n      if (metadata && typeof metadata === 'object') {\n        connection.metadata = { ...connection.metadata, ...metadata };\n        \n        this.sendToConnection(connectionId, {\n          type: 'metadata_updated',\n          data: { metadata: connection.metadata }\n        });\n      }\n    });\n\n    // Get connection info\n    this.messageHandlers.set('get_info', (connectionId: string, message: WebSocketMessage, connection: WebSocketConnection) => {\n      this.sendToConnection(connectionId, {\n        type: 'connection_info',\n        data: {\n          connectionId,\n          user: connection.user,\n          subscriptions: Array.from(connection.subscriptions),\n          metadata: connection.metadata,\n          connectedUsers: this.getConnectedUsers(),\n          serverStats: this.getServerStats()\n        }\n      });\n    });\n  }\n\n  /**\n   * Send message to specific connection\n   */\n  sendToConnection(connectionId: string, message: WebSocketMessage): boolean {\n    const connection = this.connections.get(connectionId);\n    if (!connection || connection.ws.readyState !== WebSocket.OPEN) {\n      return false;\n    }\n\n    try {\n      connection.ws.send(JSON.stringify({\n        ...message,\n        timestamp: message.timestamp || Date.now()\n      }));\n      return true;\n    } catch (error) {\n      console.error(`‚ùå Failed to send message to ${connectionId}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Send message to user (all their connections)\n   */\n  sendToUser(userId: string, message: WebSocketMessage): number {\n    const userConnections = this.userConnections.get(userId);\n    if (!userConnections) return 0;\n\n    let sentCount = 0;\n    userConnections.forEach(connectionId => {\n      if (this.sendToConnection(connectionId, message)) {\n        sentCount++;\n      }\n    });\n\n    return sentCount;\n  }\n\n  /**\n   * Broadcast message to multiple connections\n   */\n  broadcast(message: WebSocketMessage, options: BroadcastOptions = {}): number {\n    let sentCount = 0;\n    const {\n      excludeConnection,\n      includeRoles,\n      excludeRoles,\n      targetUsers,\n      subscription\n    } = options;\n\n    // Get target connections\n    let targetConnections: Set<string>;\n    \n    if (subscription) {\n      targetConnections = this.subscriptions.get(subscription) || new Set();\n    } else {\n      targetConnections = new Set(this.connections.keys());\n    }\n\n    targetConnections.forEach(connectionId => {\n      if (excludeConnection && connectionId === excludeConnection) return;\n      \n      const connection = this.connections.get(connectionId);\n      if (!connection) return;\n\n      // Filter by role\n      if (includeRoles && !includeRoles.includes(connection.user.role)) return;\n      if (excludeRoles && excludeRoles.includes(connection.user.role)) return;\n      \n      // Filter by target users\n      if (targetUsers && !targetUsers.includes(connection.user.id)) return;\n\n      if (this.sendToConnection(connectionId, message)) {\n        sentCount++;\n      }\n    });\n\n    return sentCount;\n  }\n\n  /**\n   * Start heartbeat to check connection health\n   */\n  private startHeartbeat(): void {\n    this.heartbeatInterval = setInterval(() => {\n      const now = Date.now();\n      const timeout = 30000; // 30 seconds\n\n      this.connections.forEach((connection, connectionId) => {\n        if (connection.ws.readyState === WebSocket.OPEN) {\n          if (now - connection.lastPing > timeout) {\n            console.log(`üíî Connection timeout for ${connection.user.username}`);\n            connection.ws.terminate();\n          } else {\n            connection.ws.ping();\n          }\n        }\n      });\n    }, 15000); // Check every 15 seconds\n  }\n\n  /**\n   * Get connected users\n   */\n  getConnectedUsers(): Array<{ id: string; username: string; role: string; connectionCount: number }> {\n    const users: Array<{ id: string; username: string; role: string; connectionCount: number }> = [];\n    \n    this.userConnections.forEach((connections, userId) => {\n      const firstConnection = this.connections.get(connections.values().next().value);\n      if (firstConnection) {\n        users.push({\n          id: userId,\n          username: firstConnection.user.username,\n          role: firstConnection.user.role,\n          connectionCount: connections.size\n        });\n      }\n    });\n\n    return users;\n  }\n\n  /**\n   * Get server statistics\n   */\n  getServerStats(): { totalConnections: number; totalUsers: number; subscriptions: number; uptime: number } {\n    return {\n      totalConnections: this.connections.size,\n      totalUsers: this.userConnections.size,\n      subscriptions: this.subscriptions.size,\n      uptime: process.uptime()\n    };\n  }\n\n  /**\n   * Add custom message handler\n   */\n  addMessageHandler(type: string, handler: (connectionId: string, message: WebSocketMessage, connection: WebSocketConnection) => void): void {\n    this.messageHandlers.set(type, handler);\n  }\n\n  /**\n   * Remove message handler\n   */\n  removeMessageHandler(type: string): void {\n    this.messageHandlers.delete(type);\n  }\n\n  /**\n   * Check if server is running\n   */\n  isServerRunning(): boolean {\n    return this.isRunning;\n  }\n}\n\n// Singleton instance\nlet wsManager: WebSocketManager | null = null;\n\nexport const getWebSocketManager = (port?: number): WebSocketManager => {\n  if (!wsManager) {\n    wsManager = new WebSocketManager(port);\n  }\n  return wsManager;\n};\n\nexport const initializeWebSocketServer = async (port: number = 8080): Promise<WebSocketManager> => {\n  const manager = getWebSocketManager(port);\n  await manager.start();\n  return manager;\n};\n\nexport default WebSocketManager;"