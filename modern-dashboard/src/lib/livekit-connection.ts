/**\n * LiveKit Connection Manager\n * Handles LiveKit room connections, participant management, and event handling\n */\n\nimport { \n  Room, \n  RoomEvent, \n  RemoteParticipant, \n  LocalParticipant,\n  Track,\n  RemoteTrack,\n  RemoteTrackPublication,\n  ConnectionState,\n  ParticipantEvent,\n  TrackPublication,\n  VideoPresets,\n  AudioPresets,\n  RoomOptions,\n  ConnectOptions\n} from 'livekit-client';\n\nexport interface LiveKitConfig {\n  serverUrl: string;\n  apiKey: string;\n  apiSecret: string;\n}\n\nexport interface ParticipantInfo {\n  identity: string;\n  name?: string;\n  metadata?: string;\n  connectionQuality: 'excellent' | 'good' | 'poor' | 'unknown';\n  isLocal: boolean;\n  isSpeaking: boolean;\n  audioEnabled: boolean;\n  videoEnabled: boolean;\n  screenShareEnabled: boolean;\n}\n\nexport interface ConnectionStatus {\n  state: ConnectionState;\n  isConnected: boolean;\n  isReconnecting: boolean;\n  participantCount: number;\n  roomName?: string;\n  error?: string;\n}\n\nexport interface StreamQuality {\n  resolution: { width: number; height: number };\n  frameRate: number;\n  bitrate: number;\n  codec: string;\n}\n\nexport class LiveKitConnectionManager {\n  private room: Room | null = null;\n  private config: LiveKitConfig;\n  private connectionStatus: ConnectionStatus;\n  private participants: Map<string, ParticipantInfo> = new Map();\n  private eventListeners: Map<string, Function[]> = new Map();\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n  private reconnectDelay = 1000; // Start with 1 second\n  private isReconnecting = false;\n\n  constructor(config: LiveKitConfig) {\n    this.config = config;\n    this.connectionStatus = {\n      state: ConnectionState.Disconnected,\n      isConnected: false,\n      isReconnecting: false,\n      participantCount: 0\n    };\n  }\n\n  /**\n   * Connect to a LiveKit room\n   */\n  async connect(\n    roomName: string, \n    participantToken: string, \n    options?: ConnectOptions\n  ): Promise<boolean> {\n    try {\n      console.log(`üîó Connecting to LiveKit room: ${roomName}`);\n      \n      // Create new room instance\n      this.room = new Room({\n        adaptiveStream: true,\n        dynacast: true,\n        videoCaptureDefaults: {\n          resolution: VideoPresets.h720.resolution,\n          frameRate: 30\n        },\n        audioCaptureDefaults: {\n          autoGainControl: true,\n          echoCancellation: true,\n          noiseSuppression: true\n        },\n        ...options\n      });\n\n      // Set up event listeners\n      this.setupRoomEventListeners();\n\n      // Connect to room\n      await this.room.connect(this.config.serverUrl, participantToken);\n      \n      // Update connection status\n      this.connectionStatus = {\n        state: ConnectionState.Connected,\n        isConnected: true,\n        isReconnecting: false,\n        participantCount: this.room.numParticipants,\n        roomName\n      };\n\n      // Reset reconnect attempts on successful connection\n      this.reconnectAttempts = 0;\n      this.isReconnecting = false;\n\n      console.log(`‚úÖ Connected to LiveKit room: ${roomName}`);\n      this.emit('connected', { roomName, participantCount: this.room.numParticipants });\n      \n      return true;\n    } catch (error) {\n      console.error('‚ùå Failed to connect to LiveKit room:', error);\n      this.connectionStatus.error = error instanceof Error ? error.message : 'Connection failed';\n      this.emit('connectionError', { error: this.connectionStatus.error });\n      return false;\n    }\n  }\n\n  /**\n   * Disconnect from the current room\n   */\n  async disconnect(): Promise<void> {\n    try {\n      console.log('üîå Disconnecting from LiveKit room...');\n      \n      if (this.room) {\n        await this.room.disconnect();\n        this.room = null;\n      }\n\n      // Clear participants\n      this.participants.clear();\n      \n      // Update connection status\n      this.connectionStatus = {\n        state: ConnectionState.Disconnected,\n        isConnected: false,\n        isReconnecting: false,\n        participantCount: 0\n      };\n\n      console.log('‚úÖ Disconnected from LiveKit room');\n      this.emit('disconnected');\n    } catch (error) {\n      console.error('‚ùå Error during disconnect:', error);\n    }\n  }\n\n  /**\n   * Enable/disable local camera\n   */\n  async toggleCamera(enabled?: boolean): Promise<boolean> {\n    if (!this.room?.localParticipant) {\n      console.warn('‚ö†Ô∏è No local participant available');\n      return false;\n    }\n\n    try {\n      const shouldEnable = enabled ?? !this.room.localParticipant.isCameraEnabled;\n      \n      if (shouldEnable) {\n        await this.room.localParticipant.setCameraEnabled(true);\n        console.log('üìπ Camera enabled');\n      } else {\n        await this.room.localParticipant.setCameraEnabled(false);\n        console.log('üìπ Camera disabled');\n      }\n\n      this.emit('cameraToggled', { enabled: shouldEnable });\n      return shouldEnable;\n    } catch (error) {\n      console.error('‚ùå Failed to toggle camera:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Enable/disable local microphone\n   */\n  async toggleMicrophone(enabled?: boolean): Promise<boolean> {\n    if (!this.room?.localParticipant) {\n      console.warn('‚ö†Ô∏è No local participant available');\n      return false;\n    }\n\n    try {\n      const shouldEnable = enabled ?? !this.room.localParticipant.isMicrophoneEnabled;\n      \n      if (shouldEnable) {\n        await this.room.localParticipant.setMicrophoneEnabled(true);\n        console.log('üé§ Microphone enabled');\n      } else {\n        await this.room.localParticipant.setMicrophoneEnabled(false);\n        console.log('üé§ Microphone disabled');\n      }\n\n      this.emit('microphoneToggled', { enabled: shouldEnable });\n      return shouldEnable;\n    } catch (error) {\n      console.error('‚ùå Failed to toggle microphone:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Start screen sharing\n   */\n  async startScreenShare(): Promise<boolean> {\n    if (!this.room?.localParticipant) {\n      console.warn('‚ö†Ô∏è No local participant available');\n      return false;\n    }\n\n    try {\n      await this.room.localParticipant.setScreenShareEnabled(true);\n      console.log('üñ•Ô∏è Screen sharing started');\n      this.emit('screenShareStarted');\n      return true;\n    } catch (error) {\n      console.error('‚ùå Failed to start screen sharing:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Stop screen sharing\n   */\n  async stopScreenShare(): Promise<boolean> {\n    if (!this.room?.localParticipant) {\n      console.warn('‚ö†Ô∏è No local participant available');\n      return false;\n    }\n\n    try {\n      await this.room.localParticipant.setScreenShareEnabled(false);\n      console.log('üñ•Ô∏è Screen sharing stopped');\n      this.emit('screenShareStopped');\n      return true;\n    } catch (error) {\n      console.error('‚ùå Failed to stop screen sharing:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get current connection status\n   */\n  getConnectionStatus(): ConnectionStatus {\n    return { ...this.connectionStatus };\n  }\n\n  /**\n   * Get all participants\n   */\n  getParticipants(): ParticipantInfo[] {\n    return Array.from(this.participants.values());\n  }\n\n  /**\n   * Get local participant info\n   */\n  getLocalParticipant(): ParticipantInfo | null {\n    if (!this.room?.localParticipant) return null;\n    \n    const local = this.room.localParticipant;\n    return {\n      identity: local.identity,\n      name: local.name,\n      metadata: local.metadata,\n      connectionQuality: 'excellent', // Local is always excellent\n      isLocal: true,\n      isSpeaking: local.isSpeaking,\n      audioEnabled: local.isMicrophoneEnabled,\n      videoEnabled: local.isCameraEnabled,\n      screenShareEnabled: local.isScreenShareEnabled\n    };\n  }\n\n  /**\n   * Get stream quality information\n   */\n  async getStreamQuality(): Promise<StreamQuality | null> {\n    if (!this.room?.localParticipant) return null;\n\n    try {\n      const videoTrack = this.room.localParticipant.videoTrackPublications.values().next().value;\n      if (!videoTrack?.track) return null;\n\n      const settings = videoTrack.track.getSettings();\n      const stats = await this.room.engine.getStats();\n      \n      return {\n        resolution: {\n          width: settings.width || 0,\n          height: settings.height || 0\n        },\n        frameRate: settings.frameRate || 0,\n        bitrate: 0, // Would need to calculate from stats\n        codec: 'VP8' // Default, would need to get from stats\n      };\n    } catch (error) {\n      console.error('‚ùå Failed to get stream quality:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Set up room event listeners\n   */\n  private setupRoomEventListeners(): void {\n    if (!this.room) return;\n\n    // Connection state changes\n    this.room.on(RoomEvent.ConnectionStateChanged, (state: ConnectionState) => {\n      console.log(`üîÑ Connection state changed: ${state}`);\n      this.connectionStatus.state = state;\n      this.connectionStatus.isConnected = state === ConnectionState.Connected;\n      \n      if (state === ConnectionState.Disconnected && !this.isReconnecting) {\n        this.handleDisconnection();\n      }\n      \n      this.emit('connectionStateChanged', { state });\n    });\n\n    // Participant connected\n    this.room.on(RoomEvent.ParticipantConnected, (participant: RemoteParticipant) => {\n      console.log(`üë§ Participant connected: ${participant.identity}`);\n      this.addParticipant(participant);\n      this.connectionStatus.participantCount = this.room!.numParticipants;\n      this.emit('participantConnected', { participant: this.getParticipantInfo(participant) });\n    });\n\n    // Participant disconnected\n    this.room.on(RoomEvent.ParticipantDisconnected, (participant: RemoteParticipant) => {\n      console.log(`üë§ Participant disconnected: ${participant.identity}`);\n      this.participants.delete(participant.identity);\n      this.connectionStatus.participantCount = this.room!.numParticipants;\n      this.emit('participantDisconnected', { identity: participant.identity });\n    });\n\n    // Track subscribed\n    this.room.on(RoomEvent.TrackSubscribed, (track: RemoteTrack, publication: RemoteTrackPublication, participant: RemoteParticipant) => {\n      console.log(`üì∫ Track subscribed: ${track.kind} from ${participant.identity}`);\n      this.emit('trackSubscribed', { track, participant: participant.identity });\n    });\n\n    // Track unsubscribed\n    this.room.on(RoomEvent.TrackUnsubscribed, (track: RemoteTrack, publication: RemoteTrackPublication, participant: RemoteParticipant) => {\n      console.log(`üì∫ Track unsubscribed: ${track.kind} from ${participant.identity}`);\n      this.emit('trackUnsubscribed', { track, participant: participant.identity });\n    });\n\n    // Speaking changed\n    this.room.on(RoomEvent.ActiveSpeakersChanged, (speakers: Array<LocalParticipant | RemoteParticipant>) => {\n      speakers.forEach(speaker => {\n        const participantInfo = this.participants.get(speaker.identity);\n        if (participantInfo) {\n          participantInfo.isSpeaking = true;\n        }\n      });\n      \n      // Reset speaking status for non-speakers\n      this.participants.forEach((info, identity) => {\n        if (!speakers.find(s => s.identity === identity)) {\n          info.isSpeaking = false;\n        }\n      });\n      \n      this.emit('activeSpeakersChanged', { speakers: speakers.map(s => s.identity) });\n    });\n\n    // Data received\n    this.room.on(RoomEvent.DataReceived, (payload: Uint8Array, participant?: RemoteParticipant) => {\n      const data = new TextDecoder().decode(payload);\n      console.log(`üì® Data received from ${participant?.identity || 'unknown'}:`, data);\n      this.emit('dataReceived', { data, from: participant?.identity });\n    });\n\n    // Reconnecting\n    this.room.on(RoomEvent.Reconnecting, () => {\n      console.log('üîÑ Reconnecting to room...');\n      this.connectionStatus.isReconnecting = true;\n      this.emit('reconnecting');\n    });\n\n    // Reconnected\n    this.room.on(RoomEvent.Reconnected, () => {\n      console.log('‚úÖ Reconnected to room');\n      this.connectionStatus.isReconnecting = false;\n      this.reconnectAttempts = 0;\n      this.emit('reconnected');\n    });\n  }\n\n  /**\n   * Handle disconnection and attempt reconnection\n   */\n  private async handleDisconnection(): Promise<void> {\n    if (this.isReconnecting || this.reconnectAttempts >= this.maxReconnectAttempts) {\n      return;\n    }\n\n    this.isReconnecting = true;\n    this.reconnectAttempts++;\n    \n    console.log(`üîÑ Attempting reconnection ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);\n    \n    // Exponential backoff\n    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);\n    \n    setTimeout(async () => {\n      try {\n        if (this.room && this.connectionStatus.roomName) {\n          // Try to reconnect with the same room\n          await this.room.connect(this.config.serverUrl, '');\n          this.isReconnecting = false;\n        }\n      } catch (error) {\n        console.error(`‚ùå Reconnection attempt ${this.reconnectAttempts} failed:`, error);\n        this.isReconnecting = false;\n        \n        if (this.reconnectAttempts < this.maxReconnectAttempts) {\n          this.handleDisconnection(); // Try again\n        } else {\n          console.error('‚ùå Max reconnection attempts reached');\n          this.emit('reconnectionFailed');\n        }\n      }\n    }, delay);\n  }\n\n  /**\n   * Add participant to tracking\n   */\n  private addParticipant(participant: RemoteParticipant): void {\n    const participantInfo = this.getParticipantInfo(participant);\n    this.participants.set(participant.identity, participantInfo);\n    \n    // Set up participant event listeners\n    participant.on(ParticipantEvent.TrackMuted, (publication: TrackPublication) => {\n      console.log(`üîá Track muted: ${publication.kind} from ${participant.identity}`);\n      this.updateParticipantInfo(participant);\n    });\n    \n    participant.on(ParticipantEvent.TrackUnmuted, (publication: TrackPublication) => {\n      console.log(`üîä Track unmuted: ${publication.kind} from ${participant.identity}`);\n      this.updateParticipantInfo(participant);\n    });\n  }\n\n  /**\n   * Get participant information\n   */\n  private getParticipantInfo(participant: RemoteParticipant): ParticipantInfo {\n    return {\n      identity: participant.identity,\n      name: participant.name,\n      metadata: participant.metadata,\n      connectionQuality: 'good', // Would need to implement quality detection\n      isLocal: false,\n      isSpeaking: participant.isSpeaking,\n      audioEnabled: participant.isMicrophoneEnabled,\n      videoEnabled: participant.isCameraEnabled,\n      screenShareEnabled: participant.isScreenShareEnabled\n    };\n  }\n\n  /**\n   * Update participant information\n   */\n  private updateParticipantInfo(participant: RemoteParticipant): void {\n    const info = this.participants.get(participant.identity);\n    if (info) {\n      info.audioEnabled = participant.isMicrophoneEnabled;\n      info.videoEnabled = participant.isCameraEnabled;\n      info.screenShareEnabled = participant.isScreenShareEnabled;\n      info.isSpeaking = participant.isSpeaking;\n      \n      this.emit('participantUpdated', { participant: info });\n    }\n  }\n\n  /**\n   * Send data to all participants\n   */\n  async sendData(data: string, reliable = true): Promise<boolean> {\n    if (!this.room?.localParticipant) {\n      console.warn('‚ö†Ô∏è No local participant available');\n      return false;\n    }\n\n    try {\n      const encoder = new TextEncoder();\n      const payload = encoder.encode(data);\n      \n      await this.room.localParticipant.publishData(payload, { reliable });\n      console.log('üì§ Data sent to all participants');\n      return true;\n    } catch (error) {\n      console.error('‚ùå Failed to send data:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Event listener management\n   */\n  on(event: string, callback: Function): void {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, []);\n    }\n    this.eventListeners.get(event)!.push(callback);\n  }\n\n  off(event: string, callback: Function): void {\n    const listeners = this.eventListeners.get(event);\n    if (listeners) {\n      const index = listeners.indexOf(callback);\n      if (index > -1) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n\n  private emit(event: string, data?: any): void {\n    const listeners = this.eventListeners.get(event);\n    if (listeners) {\n      listeners.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`‚ùå Error in event listener for ${event}:`, error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Cleanup resources\n   */\n  async cleanup(): Promise<void> {\n    console.log('üßπ Cleaning up LiveKit connection manager...');\n    \n    // Clear intervals\n    if ((global as any).sensorInterval) {\n      clearInterval((global as any).sensorInterval);\n    }\n    \n    // Disconnect from room\n    await this.disconnect();\n    \n    // Clear event listeners\n    this.eventListeners.clear();\n    \n    // Clear participants\n    this.participants.clear();\n    \n    console.log('‚úÖ LiveKit connection manager cleaned up');\n  }\n}\n\n// Export singleton instance\nlet liveKitManager: LiveKitConnectionManager | null = null;\n\nexport const getLiveKitManager = (config?: LiveKitConfig): LiveKitConnectionManager => {\n  if (!liveKitManager && config) {\n    liveKitManager = new LiveKitConnectionManager(config);\n  }\n  \n  if (!liveKitManager) {\n    throw new Error('LiveKit manager not initialized. Please provide config on first call.');\n  }\n  \n  return liveKitManager;\n};\n\nexport const initializeLiveKit = (config: LiveKitConfig): LiveKitConnectionManager => {\n  liveKitManager = new LiveKitConnectionManager(config);\n  return liveKitManager;\n};"