/**\n * Multi-Stream Grid Layout Component\n * Displays multiple video feeds in a responsive grid with up to 9 concurrent streams\n */\n\n'use client';\n\nimport React, { useState, useEffect, useCallback, useMemo } from 'react';\nimport { Track, RemoteVideoTrack, LocalVideoTrack } from 'livekit-client';\nimport { cn } from '@/lib/utils';\nimport { ParticipantInfo } from '@/lib/livekit-connection';\nimport { useLiveKit, useLiveKitParticipants } from './LiveKitProvider';\nimport VideoStreamComponent from './VideoStreamComponent';\n\ninterface MultiStreamGridProps {\n  className?: string;\n  maxStreams?: number;\n  showControls?: boolean;\n  showQuality?: boolean;\n  enableFocusMode?: boolean;\n  prioritizeLocal?: boolean;\n  aspectRatio?: 'video' | 'square' | 'wide';\n  onParticipantClick?: (participant: ParticipantInfo) => void;\n}\n\ninterface StreamInfo {\n  participant: ParticipantInfo;\n  videoTrack?: RemoteVideoTrack | LocalVideoTrack;\n  audioTrack?: Track;\n  priority: 'high' | 'medium' | 'low';\n  isLocal: boolean;\n}\n\ntype GridLayout = '1x1' | '1x2' | '2x2' | '1x3' | '2x3' | '3x3';\n\nexport function MultiStreamGrid({\n  className,\n  maxStreams = 9,\n  showControls = true,\n  showQuality = false,\n  enableFocusMode = true,\n  prioritizeLocal = true,\n  aspectRatio = 'video',\n  onParticipantClick\n}: MultiStreamGridProps) {\n  const { connectionManager } = useLiveKit();\n  const { participants, localParticipant } = useLiveKitParticipants();\n  \n  const [focusedParticipant, setFocusedParticipant] = useState<string | null>(null);\n  const [streams, setStreams] = useState<StreamInfo[]>([]);\n  const [gridLayout, setGridLayout] = useState<GridLayout>('1x1');\n  const [isFullscreen, setIsFullscreen] = useState(false);\n\n  // Calculate optimal grid layout based on stream count\n  const calculateGridLayout = useCallback((streamCount: number): GridLayout => {\n    if (streamCount <= 1) return '1x1';\n    if (streamCount <= 2) return '1x2';\n    if (streamCount <= 4) return '2x2';\n    if (streamCount <= 3) return '1x3';\n    if (streamCount <= 6) return '2x3';\n    return '3x3';\n  }, []);\n\n  // Get grid CSS classes\n  const getGridClasses = useCallback((layout: GridLayout) => {\n    switch (layout) {\n      case '1x1': return 'grid-cols-1 grid-rows-1';\n      case '1x2': return 'grid-cols-1 grid-rows-2 md:grid-cols-2 md:grid-rows-1';\n      case '2x2': return 'grid-cols-2 grid-rows-2';\n      case '1x3': return 'grid-cols-1 grid-rows-3 md:grid-cols-3 md:grid-rows-1';\n      case '2x3': return 'grid-cols-2 grid-rows-3 md:grid-cols-3 md:grid-rows-2';\n      case '3x3': return 'grid-cols-3 grid-rows-3';\n      default: return 'grid-cols-2 grid-rows-2';\n    }\n  }, []);\n\n  // Update streams when participants change\n  useEffect(() => {\n    const updateStreams = async () => {\n      if (!connectionManager) return;\n\n      const allStreams: StreamInfo[] = [];\n\n      // Add local participant first if prioritized\n      if (localParticipant && prioritizeLocal) {\n        allStreams.push({\n          participant: localParticipant,\n          priority: 'high',\n          isLocal: true\n        });\n      }\n\n      // Add remote participants\n      participants.forEach(participant => {\n        if (allStreams.length >= maxStreams) return;\n        \n        allStreams.push({\n          participant,\n          priority: participant.isSpeaking ? 'high' : 'medium',\n          isLocal: false\n        });\n      });\n\n      // Add local participant at the end if not prioritized\n      if (localParticipant && !prioritizeLocal && allStreams.length < maxStreams) {\n        allStreams.push({\n          participant: localParticipant,\n          priority: 'medium',\n          isLocal: true\n        });\n      }\n\n      // Sort by priority (speaking participants first)\n      allStreams.sort((a, b) => {\n        if (a.priority === 'high' && b.priority !== 'high') return -1;\n        if (b.priority === 'high' && a.priority !== 'high') return 1;\n        if (a.participant.isSpeaking && !b.participant.isSpeaking) return -1;\n        if (b.participant.isSpeaking && !a.participant.isSpeaking) return 1;\n        return 0;\n      });\n\n      setStreams(allStreams.slice(0, maxStreams));\n      setGridLayout(calculateGridLayout(allStreams.length));\n    };\n\n    updateStreams();\n  }, [participants, localParticipant, connectionManager, maxStreams, prioritizeLocal, calculateGridLayout]);\n\n  // Handle participant click\n  const handleParticipantClick = useCallback((participant: ParticipantInfo) => {\n    if (enableFocusMode) {\n      setFocusedParticipant(\n        focusedParticipant === participant.identity ? null : participant.identity\n      );\n    }\n    \n    if (onParticipantClick) {\n      onParticipantClick(participant);\n    }\n  }, [enableFocusMode, focusedParticipant, onParticipantClick]);\n\n  // Handle fullscreen toggle\n  const handleFullscreenToggle = useCallback(() => {\n    if (!document.fullscreenElement) {\n      document.documentElement.requestFullscreen();\n      setIsFullscreen(true);\n    } else {\n      document.exitFullscreen();\n      setIsFullscreen(false);\n    }\n  }, []);\n\n  // Listen for fullscreen changes\n  useEffect(() => {\n    const handleFullscreenChange = () => {\n      setIsFullscreen(!!document.fullscreenElement);\n    };\n\n    document.addEventListener('fullscreenchange', handleFullscreenChange);\n    return () => document.removeEventListener('fullscreenchange', handleFullscreenChange);\n  }, []);\n\n  // Get focused stream for focus mode\n  const focusedStream = useMemo(() => {\n    if (!focusedParticipant) return null;\n    return streams.find(stream => stream.participant.identity === focusedParticipant);\n  }, [focusedParticipant, streams]);\n\n  // Get non-focused streams for focus mode\n  const nonFocusedStreams = useMemo(() => {\n    if (!focusedParticipant) return streams;\n    return streams.filter(stream => stream.participant.identity !== focusedParticipant);\n  }, [focusedParticipant, streams]);\n\n  // No streams available\n  if (streams.length === 0) {\n    return (\n      <div className={cn(\n        'flex items-center justify-center bg-gray-900 rounded-lg border border-gray-700',\n        'min-h-[400px]',\n        className\n      )}>\n        <div className=\"text-center space-y-4\">\n          <div className=\"text-6xl\">ðŸ“¹</div>\n          <div className=\"space-y-2\">\n            <h3 className=\"text-lg font-medium text-gray-300\">No Video Streams</h3>\n            <p className=\"text-sm text-gray-500\">\n              Waiting for participants to join and enable their cameras\n            </p>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className={cn('relative', className)}>\n      {/* Grid Controls */}\n      <div className=\"absolute top-4 right-4 z-10 flex items-center space-x-2\">\n        {/* Stream Count */}\n        <div className=\"bg-black/70 backdrop-blur-sm rounded px-3 py-1\">\n          <span className=\"text-sm text-white\">\n            {streams.length} stream{streams.length !== 1 ? 's' : ''}\n          </span>\n        </div>\n\n        {/* Focus Mode Toggle */}\n        {enableFocusMode && streams.length > 1 && (\n          <button\n            onClick={() => setFocusedParticipant(null)}\n            className={cn(\n              'bg-black/70 backdrop-blur-sm rounded px-3 py-1 text-sm transition-colors',\n              focusedParticipant \n                ? 'text-blue-400 hover:text-blue-300' \n                : 'text-gray-400 hover:text-gray-300'\n            )}\n          >\n            {focusedParticipant ? 'ðŸ“Œ Focused' : 'ðŸ“Œ Focus'}\n          </button>\n        )}\n\n        {/* Fullscreen Toggle */}\n        <button\n          onClick={handleFullscreenToggle}\n          className=\"bg-black/70 backdrop-blur-sm rounded px-3 py-1 text-sm text-white hover:text-blue-400 transition-colors\"\n        >\n          {isFullscreen ? 'ðŸ——' : 'â›¶'}\n        </button>\n      </div>\n\n      {/* Focus Mode Layout */}\n      {focusedStream && (\n        <div className=\"space-y-4\">\n          {/* Main Focused Stream */}\n          <div className=\"aspect-video\">\n            <VideoStreamComponent\n              participant={focusedStream.participant}\n              track={focusedStream.videoTrack}\n              isLocal={focusedStream.isLocal}\n              showControls={showControls}\n              showQuality={showQuality}\n              aspectRatio=\"wide\"\n              priority=\"high\"\n              onTrackClick={handleParticipantClick}\n              className=\"w-full h-full\"\n            />\n          </div>\n\n          {/* Thumbnail Grid */}\n          {nonFocusedStreams.length > 0 && (\n            <div className=\"grid grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-2\">\n              {nonFocusedStreams.map((stream) => (\n                <VideoStreamComponent\n                  key={stream.participant.identity}\n                  participant={stream.participant}\n                  track={stream.videoTrack}\n                  isLocal={stream.isLocal}\n                  showControls={false}\n                  showQuality={false}\n                  aspectRatio=\"square\"\n                  priority={stream.priority}\n                  onTrackClick={handleParticipantClick}\n                  className=\"cursor-pointer hover:ring-2 hover:ring-blue-500 transition-all\"\n                />\n              ))}\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Grid Mode Layout */}\n      {!focusedStream && (\n        <div className={cn(\n          'grid gap-2 md:gap-4',\n          getGridClasses(gridLayout),\n          'min-h-[400px]'\n        )}>\n          {streams.map((stream, index) => (\n            <VideoStreamComponent\n              key={stream.participant.identity}\n              participant={stream.participant}\n              track={stream.videoTrack}\n              isLocal={stream.isLocal}\n              showControls={showControls}\n              showQuality={showQuality}\n              aspectRatio={aspectRatio}\n              priority={stream.priority}\n              onTrackClick={enableFocusMode ? handleParticipantClick : onParticipantClick}\n              className={cn(\n                'transition-all duration-200',\n                enableFocusMode && 'cursor-pointer hover:ring-2 hover:ring-blue-500',\n                // Highlight speaking participants\n                stream.participant.isSpeaking && 'ring-2 ring-green-500',\n                // Special styling for first stream in single mode\n                streams.length === 1 && 'col-span-full row-span-full'\n              )}\n            />\n          ))}\n        </div>\n      )}\n\n      {/* Stream Quality Summary */}\n      {showQuality && (\n        <div className=\"absolute bottom-4 left-4 z-10\">\n          <div className=\"bg-black/80 backdrop-blur-sm rounded p-3 text-xs text-white space-y-1\">\n            <div className=\"font-medium\">Stream Quality</div>\n            {streams.map((stream) => (\n              <div key={stream.participant.identity} className=\"flex items-center justify-between space-x-4\">\n                <span className=\"truncate max-w-20\">\n                  {stream.participant.name || stream.participant.identity}\n                </span>\n                <span className={cn(\n                  'font-mono',\n                  stream.participant.connectionQuality === 'excellent' && 'text-green-400',\n                  stream.participant.connectionQuality === 'good' && 'text-yellow-400',\n                  stream.participant.connectionQuality === 'poor' && 'text-red-400'\n                )}>\n                  {stream.participant.connectionQuality}\n                </span>\n              </div>\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Speaking Indicator */}\n      {streams.some(s => s.participant.isSpeaking) && (\n        <div className=\"absolute top-4 left-4 z-10\">\n          <div className=\"bg-green-600/80 backdrop-blur-sm rounded px-3 py-1\">\n            <div className=\"flex items-center space-x-2\">\n              <div className=\"w-2 h-2 bg-green-400 rounded-full animate-pulse\"></div>\n              <span className=\"text-sm text-white font-medium\">Speaking</span>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Layout Info (Debug) */}\n      {process.env.NODE_ENV === 'development' && (\n        <div className=\"absolute bottom-4 right-4 z-10\">\n          <div className=\"bg-black/80 backdrop-blur-sm rounded p-2 text-xs text-gray-400\">\n            Layout: {gridLayout} | Streams: {streams.length}/{maxStreams}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n\n// Memoized version for performance\nexport const MemoizedMultiStreamGrid = React.memo(MultiStreamGrid);\n\n// Default export\nexport default MultiStreamGrid;"