/**\n * LiveKit Provider Component\n * React context provider for LiveKit functionality with connection state management\n */\n\n'use client';\n\nimport React, { createContext, useContext, useEffect, useState, useCallback, useRef } from 'react';\nimport { getLiveKitManager, LiveKitConnectionManager, ConnectionStatus, ParticipantInfo } from '@/lib/livekit-connection';\n\n// LiveKit configuration from environment\nconst LIVEKIT_CONFIG = {\n  serverUrl: process.env.NEXT_PUBLIC_LIVEKIT_WS_URL || 'ws://localhost:7880',\n  apiKey: process.env.NEXT_PUBLIC_LIVEKIT_API_KEY || 'devkey',\n  apiSecret: process.env.LIVEKIT_API_SECRET || 'secret'\n};\n\ninterface LiveKitContextType {\n  // Connection management\n  connectionManager: LiveKitConnectionManager | null;\n  connectionStatus: ConnectionStatus;\n  isConnected: boolean;\n  isConnecting: boolean;\n  connectionError: string | null;\n  \n  // Room management\n  currentRoom: string | null;\n  participants: ParticipantInfo[];\n  localParticipant: ParticipantInfo | null;\n  \n  // Media controls\n  isCameraEnabled: boolean;\n  isMicrophoneEnabled: boolean;\n  isScreenSharing: boolean;\n  \n  // Connection methods\n  connect: (roomName: string, participantName: string, participantIdentity?: string) => Promise<boolean>;\n  disconnect: () => Promise<void>;\n  \n  // Media control methods\n  toggleCamera: (enabled?: boolean) => Promise<boolean>;\n  toggleMicrophone: (enabled?: boolean) => Promise<boolean>;\n  startScreenShare: () => Promise<boolean>;\n  stopScreenShare: () => Promise<boolean>;\n  \n  // Data methods\n  sendData: (data: string, reliable?: boolean) => Promise<boolean>;\n  \n  // Utility methods\n  getStreamQuality: () => Promise<any>;\n  refreshParticipants: () => void;\n}\n\nconst LiveKitContext = createContext<LiveKitContextType | null>(null);\n\ninterface LiveKitProviderProps {\n  children: React.ReactNode;\n  autoReconnect?: boolean;\n  maxReconnectAttempts?: number;\n}\n\nexport function LiveKitProvider({ \n  children, \n  autoReconnect = true, \n  maxReconnectAttempts = 5 \n}: LiveKitProviderProps) {\n  // Connection state\n  const [connectionManager, setConnectionManager] = useState<LiveKitConnectionManager | null>(null);\n  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>({\n    state: 'disconnected' as any,\n    isConnected: false,\n    isReconnecting: false,\n    participantCount: 0\n  });\n  const [isConnecting, setIsConnecting] = useState(false);\n  const [connectionError, setConnectionError] = useState<string | null>(null);\n  \n  // Room state\n  const [currentRoom, setCurrentRoom] = useState<string | null>(null);\n  const [participants, setParticipants] = useState<ParticipantInfo[]>([]);\n  const [localParticipant, setLocalParticipant] = useState<ParticipantInfo | null>(null);\n  \n  // Media state\n  const [isCameraEnabled, setIsCameraEnabled] = useState(false);\n  const [isMicrophoneEnabled, setIsMicrophoneEnabled] = useState(false);\n  const [isScreenSharing, setIsScreenSharing] = useState(false);\n  \n  // Refs for cleanup\n  const eventListenersRef = useRef<Array<() => void>>([]);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Initialize connection manager\n  useEffect(() => {\n    try {\n      const manager = getLiveKitManager(LIVEKIT_CONFIG);\n      setConnectionManager(manager);\n      console.log('✅ LiveKit connection manager initialized');\n    } catch (error) {\n      console.error('❌ Failed to initialize LiveKit connection manager:', error);\n      setConnectionError('Failed to initialize LiveKit');\n    }\n  }, []);\n\n  // Set up event listeners when connection manager is available\n  useEffect(() => {\n    if (!connectionManager) return;\n\n    const setupEventListeners = () => {\n      // Connection events\n      const onConnected = (data: any) => {\n        console.log('🔗 LiveKit connected:', data);\n        setCurrentRoom(data.roomName);\n        setIsConnecting(false);\n        setConnectionError(null);\n        refreshParticipants();\n      };\n\n      const onDisconnected = () => {\n        console.log('🔌 LiveKit disconnected');\n        setCurrentRoom(null);\n        setParticipants([]);\n        setLocalParticipant(null);\n        setIsConnecting(false);\n        setIsCameraEnabled(false);\n        setIsMicrophoneEnabled(false);\n        setIsScreenSharing(false);\n      };\n\n      const onConnectionStateChanged = (data: { state: any }) => {\n        console.log('🔄 Connection state changed:', data.state);\n        setConnectionStatus(prev => ({\n          ...prev,\n          state: data.state,\n          isConnected: data.state === 'connected'\n        }));\n      };\n\n      const onConnectionError = (data: { error: string }) => {\n        console.error('❌ LiveKit connection error:', data.error);\n        setConnectionError(data.error);\n        setIsConnecting(false);\n      };\n\n      // Participant events\n      const onParticipantConnected = (data: { participant: ParticipantInfo }) => {\n        console.log('👤 Participant connected:', data.participant.identity);\n        refreshParticipants();\n      };\n\n      const onParticipantDisconnected = (data: { identity: string }) => {\n        console.log('👤 Participant disconnected:', data.identity);\n        setParticipants(prev => prev.filter(p => p.identity !== data.identity));\n      };\n\n      const onParticipantUpdated = (data: { participant: ParticipantInfo }) => {\n        console.log('👤 Participant updated:', data.participant.identity);\n        setParticipants(prev => \n          prev.map(p => p.identity === data.participant.identity ? data.participant : p)\n        );\n      };\n\n      // Media events\n      const onCameraToggled = (data: { enabled: boolean }) => {\n        console.log('📹 Camera toggled:', data.enabled);\n        setIsCameraEnabled(data.enabled);\n        refreshLocalParticipant();\n      };\n\n      const onMicrophoneToggled = (data: { enabled: boolean }) => {\n        console.log('🎤 Microphone toggled:', data.enabled);\n        setIsMicrophoneEnabled(data.enabled);\n        refreshLocalParticipant();\n      };\n\n      const onScreenShareStarted = () => {\n        console.log('🖥️ Screen share started');\n        setIsScreenSharing(true);\n        refreshLocalParticipant();\n      };\n\n      const onScreenShareStopped = () => {\n        console.log('🖥️ Screen share stopped');\n        setIsScreenSharing(false);\n        refreshLocalParticipant();\n      };\n\n      // Reconnection events\n      const onReconnecting = () => {\n        console.log('🔄 Reconnecting...');\n        setConnectionStatus(prev => ({ ...prev, isReconnecting: true }));\n      };\n\n      const onReconnected = () => {\n        console.log('✅ Reconnected');\n        setConnectionStatus(prev => ({ ...prev, isReconnecting: false }));\n        refreshParticipants();\n      };\n\n      const onReconnectionFailed = () => {\n        console.error('❌ Reconnection failed');\n        setConnectionError('Reconnection failed after maximum attempts');\n        setConnectionStatus(prev => ({ ...prev, isReconnecting: false }));\n      };\n\n      // Register event listeners\n      connectionManager.on('connected', onConnected);\n      connectionManager.on('disconnected', onDisconnected);\n      connectionManager.on('connectionStateChanged', onConnectionStateChanged);\n      connectionManager.on('connectionError', onConnectionError);\n      connectionManager.on('participantConnected', onParticipantConnected);\n      connectionManager.on('participantDisconnected', onParticipantDisconnected);\n      connectionManager.on('participantUpdated', onParticipantUpdated);\n      connectionManager.on('cameraToggled', onCameraToggled);\n      connectionManager.on('microphoneToggled', onMicrophoneToggled);\n      connectionManager.on('screenShareStarted', onScreenShareStarted);\n      connectionManager.on('screenShareStopped', onScreenShareStopped);\n      connectionManager.on('reconnecting', onReconnecting);\n      connectionManager.on('reconnected', onReconnected);\n      connectionManager.on('reconnectionFailed', onReconnectionFailed);\n\n      // Store cleanup functions\n      eventListenersRef.current = [\n        () => connectionManager.off('connected', onConnected),\n        () => connectionManager.off('disconnected', onDisconnected),\n        () => connectionManager.off('connectionStateChanged', onConnectionStateChanged),\n        () => connectionManager.off('connectionError', onConnectionError),\n        () => connectionManager.off('participantConnected', onParticipantConnected),\n        () => connectionManager.off('participantDisconnected', onParticipantDisconnected),\n        () => connectionManager.off('participantUpdated', onParticipantUpdated),\n        () => connectionManager.off('cameraToggled', onCameraToggled),\n        () => connectionManager.off('microphoneToggled', onMicrophoneToggled),\n        () => connectionManager.off('screenShareStarted', onScreenShareStarted),\n        () => connectionManager.off('screenShareStopped', onScreenShareStopped),\n        () => connectionManager.off('reconnecting', onReconnecting),\n        () => connectionManager.off('reconnected', onReconnected),\n        () => connectionManager.off('reconnectionFailed', onReconnectionFailed)\n      ];\n    };\n\n    setupEventListeners();\n\n    // Cleanup function\n    return () => {\n      eventListenersRef.current.forEach(cleanup => cleanup());\n      eventListenersRef.current = [];\n    };\n  }, [connectionManager]);\n\n  // Update connection status from manager\n  useEffect(() => {\n    if (!connectionManager) return;\n\n    const updateStatus = () => {\n      const status = connectionManager.getConnectionStatus();\n      setConnectionStatus(status);\n    };\n\n    // Update status periodically\n    const interval = setInterval(updateStatus, 1000);\n    updateStatus(); // Initial update\n\n    return () => clearInterval(interval);\n  }, [connectionManager]);\n\n  // Refresh participants list\n  const refreshParticipants = useCallback(() => {\n    if (!connectionManager) return;\n\n    const allParticipants = connectionManager.getParticipants();\n    const localPart = connectionManager.getLocalParticipant();\n    \n    setParticipants(allParticipants);\n    setLocalParticipant(localPart);\n    \n    // Update media states from local participant\n    if (localPart) {\n      setIsCameraEnabled(localPart.videoEnabled);\n      setIsMicrophoneEnabled(localPart.audioEnabled);\n      setIsScreenSharing(localPart.screenShareEnabled);\n    }\n  }, [connectionManager]);\n\n  // Refresh local participant info\n  const refreshLocalParticipant = useCallback(() => {\n    if (!connectionManager) return;\n    \n    const localPart = connectionManager.getLocalParticipant();\n    setLocalParticipant(localPart);\n  }, [connectionManager]);\n\n  // Generate access token\n  const generateToken = async (roomName: string, participantName: string, participantIdentity?: string): Promise<string | null> => {\n    try {\n      const token = localStorage.getItem('auth_token');\n      if (!token) {\n        throw new Error('No authentication token available');\n      }\n\n      const response = await fetch('/api/livekit/token', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${token}`\n        },\n        body: JSON.stringify({\n          roomName,\n          participantName,\n          participantIdentity\n        })\n      });\n\n      if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.message || 'Failed to generate token');\n      }\n\n      const data = await response.json();\n      return data.data.token;\n    } catch (error) {\n      console.error('❌ Failed to generate LiveKit token:', error);\n      return null;\n    }\n  };\n\n  // Connect to room\n  const connect = useCallback(async (\n    roomName: string, \n    participantName: string, \n    participantIdentity?: string\n  ): Promise<boolean> => {\n    if (!connectionManager) {\n      setConnectionError('Connection manager not initialized');\n      return false;\n    }\n\n    if (connectionStatus.isConnected) {\n      console.warn('⚠️ Already connected to a room');\n      return true;\n    }\n\n    setIsConnecting(true);\n    setConnectionError(null);\n\n    try {\n      // Generate access token\n      const token = await generateToken(roomName, participantName, participantIdentity);\n      if (!token) {\n        throw new Error('Failed to generate access token');\n      }\n\n      // Connect to room\n      const success = await connectionManager.connect(roomName, token);\n      \n      if (success) {\n        console.log(`✅ Connected to LiveKit room: ${roomName}`);\n        return true;\n      } else {\n        throw new Error('Connection failed');\n      }\n    } catch (error) {\n      console.error('❌ Failed to connect to LiveKit room:', error);\n      setConnectionError(error instanceof Error ? error.message : 'Connection failed');\n      setIsConnecting(false);\n      return false;\n    }\n  }, [connectionManager, connectionStatus.isConnected]);\n\n  // Disconnect from room\n  const disconnect = useCallback(async (): Promise<void> => {\n    if (!connectionManager) return;\n\n    try {\n      await connectionManager.disconnect();\n      console.log('✅ Disconnected from LiveKit room');\n    } catch (error) {\n      console.error('❌ Failed to disconnect from LiveKit room:', error);\n    }\n  }, [connectionManager]);\n\n  // Toggle camera\n  const toggleCamera = useCallback(async (enabled?: boolean): Promise<boolean> => {\n    if (!connectionManager) return false;\n    return await connectionManager.toggleCamera(enabled);\n  }, [connectionManager]);\n\n  // Toggle microphone\n  const toggleMicrophone = useCallback(async (enabled?: boolean): Promise<boolean> => {\n    if (!connectionManager) return false;\n    return await connectionManager.toggleMicrophone(enabled);\n  }, [connectionManager]);\n\n  // Start screen share\n  const startScreenShare = useCallback(async (): Promise<boolean> => {\n    if (!connectionManager) return false;\n    return await connectionManager.startScreenShare();\n  }, [connectionManager]);\n\n  // Stop screen share\n  const stopScreenShare = useCallback(async (): Promise<boolean> => {\n    if (!connectionManager) return false;\n    return await connectionManager.stopScreenShare();\n  }, [connectionManager]);\n\n  // Send data\n  const sendData = useCallback(async (data: string, reliable = true): Promise<boolean> => {\n    if (!connectionManager) return false;\n    return await connectionManager.sendData(data, reliable);\n  }, [connectionManager]);\n\n  // Get stream quality\n  const getStreamQuality = useCallback(async () => {\n    if (!connectionManager) return null;\n    return await connectionManager.getStreamQuality();\n  }, [connectionManager]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      \n      // Cleanup connection manager\n      if (connectionManager) {\n        connectionManager.cleanup();\n      }\n    };\n  }, [connectionManager]);\n\n  const contextValue: LiveKitContextType = {\n    // Connection management\n    connectionManager,\n    connectionStatus,\n    isConnected: connectionStatus.isConnected,\n    isConnecting,\n    connectionError,\n    \n    // Room management\n    currentRoom,\n    participants,\n    localParticipant,\n    \n    // Media controls\n    isCameraEnabled,\n    isMicrophoneEnabled,\n    isScreenSharing,\n    \n    // Connection methods\n    connect,\n    disconnect,\n    \n    // Media control methods\n    toggleCamera,\n    toggleMicrophone,\n    startScreenShare,\n    stopScreenShare,\n    \n    // Data methods\n    sendData,\n    \n    // Utility methods\n    getStreamQuality,\n    refreshParticipants\n  };\n\n  return (\n    <LiveKitContext.Provider value={contextValue}>\n      {children}\n    </LiveKitContext.Provider>\n  );\n}\n\n// Hook to use LiveKit context\nexport function useLiveKit(): LiveKitContextType {\n  const context = useContext(LiveKitContext);\n  \n  if (!context) {\n    throw new Error('useLiveKit must be used within a LiveKitProvider');\n  }\n  \n  return context;\n}\n\n// Hook for connection status only\nexport function useLiveKitConnection() {\n  const { connectionStatus, isConnected, isConnecting, connectionError } = useLiveKit();\n  \n  return {\n    connectionStatus,\n    isConnected,\n    isConnecting,\n    connectionError\n  };\n}\n\n// Hook for participants only\nexport function useLiveKitParticipants() {\n  const { participants, localParticipant, currentRoom } = useLiveKit();\n  \n  return {\n    participants,\n    localParticipant,\n    currentRoom,\n    participantCount: participants.length\n  };\n}\n\n// Hook for media controls only\nexport function useLiveKitMedia() {\n  const { \n    isCameraEnabled, \n    isMicrophoneEnabled, \n    isScreenSharing,\n    toggleCamera,\n    toggleMicrophone,\n    startScreenShare,\n    stopScreenShare\n  } = useLiveKit();\n  \n  return {\n    isCameraEnabled,\n    isMicrophoneEnabled,\n    isScreenSharing,\n    toggleCamera,\n    toggleMicrophone,\n    startScreenShare,\n    stopScreenShare\n  };\n}"