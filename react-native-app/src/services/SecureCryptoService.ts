/**\n * Secure Crypto Service\n * Implements libsodium-based encryption for tactical communications\n * Based on security recommendations for production-ready encryption\n */\n\nimport sodium from 'libsodium-wrappers';\nimport * as SecureStore from 'expo-secure-store';\nimport * as LocalAuthentication from 'expo-local-authentication';\n\nexport interface KeyPair {\n  publicKey: Uint8Array;\n  privateKey: Uint8Array;\n}\n\nexport interface EncryptedData {\n  ciphertext: Uint8Array;\n  nonce: Uint8Array;\n  algorithm: 'xchacha20poly1305' | 'aes256gcm';\n  keyId?: string;\n}\n\nexport interface KeyBackup {\n  encryptedPrivateKey: Uint8Array;\n  salt: Uint8Array;\n  nonce: Uint8Array;\n  algorithm: 'argon2id';\n  opsLimit: number;\n  memLimit: number;\n}\n\nexport interface SecureSession {\n  sessionId: string;\n  sharedKey: Uint8Array;\n  created: Date;\n  expires: Date;\n  participants: string[];\n}\n\n/**\n * Secure Crypto Service\n * Handles all cryptographic operations using libsodium\n */\nexport class SecureCryptoService {\n  private initialized = false;\n  private userKeyPairs: Map<string, KeyPair> = new Map();\n  private publicKeys: Map<string, Uint8Array> = new Map();\n  private sessionKeys: Map<string, Uint8Array> = new Map();\n  private fileKeys: Map<string, Uint8Array> = new Map();\n  private currentUserId: string | null = null;\n\n  /**\n   * Initialize the crypto service\n   */\n  async initialize(): Promise<void> {\n    try {\n      await sodium.ready;\n      this.initialized = true;\n    } catch (error) {\n      console.error('Failed to initialize crypto service:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Generate or load user keypair\n   */\n  async initializeUserKeypair(userId: string): Promise<string> {\n    if (!this.initialized) {\n      throw new Error('Crypto service not initialized');\n    }\n\n    this.currentUserId = userId;\n\n    try {\n      // Try to load existing keypair\n      const existingPrivKey = await SecureStore.getItemAsync(`${userId}:privKey`);\n      \n      if (existingPrivKey) {\n        const privateKey = sodium.from_base64(existingPrivKey);\n        const publicKey = sodium.crypto_scalarmult_base(privateKey);\n        \n        this.userKeyPairs.set(userId, { publicKey, privateKey });\n        return sodium.to_base64(publicKey);\n      } else {\n        // Generate new keypair\n        return await this.generateNewKeypair(userId);\n      }\n    } catch (error) {\n      console.error('Failed to initialize user keypair:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Generate new keypair for user\n   */\n  async generateNewKeypair(userId: string): Promise<string> {\n    try {\n      // Generate X25519 keypair for ECDH\n      const keyPair = sodium.crypto_kx_keypair();\n      \n      // Store private key securely\n      await SecureStore.setItemAsync(\n        `${userId}:privKey`, \n        sodium.to_base64(keyPair.privateKey)\n      );\n      \n      this.userKeyPairs.set(userId, keyPair);\n      \n      return sodium.to_base64(keyPair.publicKey);\n    } catch (error) {\n      console.error('Failed to generate new keypair:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create password-protected backup of private key\n   */\n  async createKeyBackup(userId: string, password: string): Promise<KeyBackup> {\n    const keyPair = this.userKeyPairs.get(userId);\n    \n    if (!keyPair) {\n      throw new Error('User keypair not found');\n    }\n\n    try {\n      // Generate salt for password hashing\n      const salt = sodium.randombytes_buf(sodium.crypto_pwhash_SALTBYTES);\n      \n      // Derive key from password using Argon2id\n      const derivedKey = sodium.crypto_pwhash(\n        32, // 32 bytes key\n        password,\n        salt,\n        sodium.crypto_pwhash_OPSLIMIT_MODERATE,\n        sodium.crypto_pwhash_MEMLIMIT_MODERATE,\n        sodium.crypto_pwhash_ALG_ARGON2ID13\n      );\n      \n      // Generate nonce for encryption\n      const nonce = sodium.randombytes_buf(sodium.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES);\n      \n      // Encrypt private key\n      const encryptedPrivateKey = sodium.crypto_aead_xchacha20poly1305_ietf_encrypt(\n        keyPair.privateKey,\n        null,\n        null,\n        nonce,\n        derivedKey\n      );\n      \n      return {\n        encryptedPrivateKey,\n        salt,\n        nonce,\n        algorithm: 'argon2id',\n        opsLimit: sodium.crypto_pwhash_OPSLIMIT_MODERATE,\n        memLimit: sodium.crypto_pwhash_MEMLIMIT_MODERATE,\n      };\n    } catch (error) {\n      console.error('Failed to create key backup:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Restore private key from password-protected backup\n   */\n  async restoreFromBackup(\n    userId: string, \n    backup: KeyBackup, \n    password: string\n  ): Promise<void> {\n    try {\n      // Derive key from password\n      const derivedKey = sodium.crypto_pwhash(\n        32,\n        password,\n        backup.salt,\n        backup.opsLimit,\n        backup.memLimit,\n        sodium.crypto_pwhash_ALG_ARGON2ID13\n      );\n      \n      // Decrypt private key\n      const privateKey = sodium.crypto_aead_xchacha20poly1305_ietf_decrypt(\n        null,\n        backup.encryptedPrivateKey,\n        null,\n        backup.nonce,\n        derivedKey\n      );\n      \n      // Derive public key\n      const publicKey = sodium.crypto_scalarmult_base(privateKey);\n      \n      // Store keypair\n      this.userKeyPairs.set(userId, { publicKey, privateKey });\n      \n      // Store private key securely\n      await SecureStore.setItemAsync(\n        `${userId}:privKey`, \n        sodium.to_base64(privateKey)\n      );\n      \n      this.currentUserId = userId;\n    } catch (error) {\n      console.error('Failed to restore from backup:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Add public key for another user\n   */\n  addUserPublicKey(userId: string, publicKeyBase64: string): void {\n    try {\n      const publicKey = sodium.from_base64(publicKeyBase64);\n      this.publicKeys.set(userId, publicKey);\n    } catch (error) {\n      console.error('Failed to add user public key:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get user's public key\n   */\n  getUserPublicKey(userId?: string): string | null {\n    const targetUserId = userId || this.currentUserId;\n    \n    if (!targetUserId) {\n      return null;\n    }\n\n    const keyPair = this.userKeyPairs.get(targetUserId);\n    \n    if (keyPair) {\n      return sodium.to_base64(keyPair.publicKey);\n    }\n\n    const publicKey = this.publicKeys.get(targetUserId);\n    return publicKey ? sodium.to_base64(publicKey) : null;\n  }\n\n  /**\n   * Create shared secret with another user (ECDH)\n   */\n  createSharedSecret(otherUserId: string): Uint8Array {\n    if (!this.currentUserId) {\n      throw new Error('Current user not set');\n    }\n\n    const myKeyPair = this.userKeyPairs.get(this.currentUserId);\n    const otherPublicKey = this.publicKeys.get(otherUserId);\n\n    if (!myKeyPair || !otherPublicKey) {\n      throw new Error('Missing keys for shared secret');\n    }\n\n    try {\n      // Perform ECDH\n      const sharedSecret = sodium.crypto_scalarmult(myKeyPair.privateKey, otherPublicKey);\n      \n      // Derive session key using BLAKE2b\n      return sodium.crypto_generichash(32, sharedSecret);\n    } catch (error) {\n      console.error('Failed to create shared secret:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Encrypt data with symmetric key\n   */\n  encryptSymmetric(data: Uint8Array, key: Uint8Array): EncryptedData {\n    try {\n      const nonce = sodium.randombytes_buf(sodium.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES);\n      \n      const ciphertext = sodium.crypto_aead_xchacha20poly1305_ietf_encrypt(\n        data,\n        null, // no additional data\n        null, // no secret nonce\n        nonce,\n        key\n      );\n      \n      return {\n        ciphertext,\n        nonce,\n        algorithm: 'xchacha20poly1305',\n      };\n    } catch (error) {\n      console.error('Failed to encrypt data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Decrypt data with symmetric key\n   */\n  decryptSymmetric(encryptedData: EncryptedData, key: Uint8Array): Uint8Array {\n    try {\n      return sodium.crypto_aead_xchacha20poly1305_ietf_decrypt(\n        null, // no secret nonce\n        encryptedData.ciphertext,\n        null, // no additional data\n        encryptedData.nonce,\n        key\n      );\n    } catch (error) {\n      console.error('Failed to decrypt data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Encrypt message for specific recipients\n   */\n  async encryptForRecipients(\n    message: string, \n    recipients: string[]\n  ): Promise<{\n    encryptedMessage: EncryptedData;\n    encryptedKeys: Record<string, string>;\n  }> {\n    if (!this.currentUserId) {\n      throw new Error('Current user not set');\n    }\n\n    try {\n      // Generate random symmetric key\n      const messageKey = sodium.randombytes_buf(32);\n      \n      // Encrypt message with symmetric key\n      const messageBytes = sodium.from_string(message);\n      const encryptedMessage = this.encryptSymmetric(messageBytes, messageKey);\n      \n      // Encrypt message key for each recipient\n      const encryptedKeys: Record<string, string> = {};\n      \n      for (const recipientId of recipients) {\n        const sharedSecret = this.createSharedSecret(recipientId);\n        const encryptedKey = this.encryptSymmetric(messageKey, sharedSecret);\n        \n        // Store as base64: nonce:ciphertext\n        encryptedKeys[recipientId] = \n          sodium.to_base64(encryptedKey.nonce) + ':' + \n          sodium.to_base64(encryptedKey.ciphertext);\n      }\n      \n      return {\n        encryptedMessage,\n        encryptedKeys,\n      };\n    } catch (error) {\n      console.error('Failed to encrypt for recipients:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Decrypt message from sender\n   */\n  async decryptFromSender(\n    encryptedMessage: EncryptedData,\n    encryptedKey: string,\n    senderId: string\n  ): Promise<string> {\n    if (!this.currentUserId) {\n      throw new Error('Current user not set');\n    }\n\n    try {\n      // Parse encrypted key (nonce:ciphertext)\n      const [nonceB64, ciphertextB64] = encryptedKey.split(':');\n      const keyNonce = sodium.from_base64(nonceB64);\n      const keyCiphertext = sodium.from_base64(ciphertextB64);\n      \n      // Create shared secret with sender\n      const sharedSecret = this.createSharedSecret(senderId);\n      \n      // Decrypt message key\n      const messageKey = this.decryptSymmetric({\n        ciphertext: keyCiphertext,\n        nonce: keyNonce,\n        algorithm: 'xchacha20poly1305',\n      }, sharedSecret);\n      \n      // Decrypt message\n      const messageBytes = this.decryptSymmetric(encryptedMessage, messageKey);\n      \n      return sodium.to_string(messageBytes);\n    } catch (error) {\n      console.error('Failed to decrypt from sender:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Encrypt file with random key\n   */\n  async encryptFile(fileData: Uint8Array): Promise<{\n    encryptedFile: EncryptedData;\n    fileKey: Uint8Array;\n  }> {\n    try {\n      const fileKey = sodium.randombytes_buf(32);\n      const encryptedFile = this.encryptSymmetric(fileData, fileKey);\n      \n      return {\n        encryptedFile,\n        fileKey,\n      };\n    } catch (error) {\n      console.error('Failed to encrypt file:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Decrypt file with key\n   */\n  async decryptFile(encryptedFile: EncryptedData, fileKey: Uint8Array): Promise<Uint8Array> {\n    try {\n      return this.decryptSymmetric(encryptedFile, fileKey);\n    } catch (error) {\n      console.error('Failed to decrypt file:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Generate secure random bytes\n   */\n  generateRandomBytes(length: number): Uint8Array {\n    return sodium.randombytes_buf(length);\n  }\n\n  /**\n   * Hash data using BLAKE2b\n   */\n  hashData(data: Uint8Array, length: number = 32): Uint8Array {\n    return sodium.crypto_generichash(length, data);\n  }\n\n  /**\n   * Create digital signature\n   */\n  async signData(data: Uint8Array, userId?: string): Promise<Uint8Array> {\n    const targetUserId = userId || this.currentUserId;\n    \n    if (!targetUserId) {\n      throw new Error('User not specified');\n    }\n\n    const keyPair = this.userKeyPairs.get(targetUserId);\n    \n    if (!keyPair) {\n      throw new Error('User keypair not found');\n    }\n\n    try {\n      // Convert X25519 key to Ed25519 for signing (simplified approach)\n      // In production, you'd want separate signing keys\n      const signingKey = sodium.crypto_sign_seed_keypair(keyPair.privateKey.slice(0, 32));\n      \n      return sodium.crypto_sign_detached(data, signingKey.privateKey);\n    } catch (error) {\n      console.error('Failed to sign data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Verify digital signature\n   */\n  async verifySignature(\n    data: Uint8Array, \n    signature: Uint8Array, \n    userId: string\n  ): Promise<boolean> {\n    const publicKey = this.publicKeys.get(userId);\n    \n    if (!publicKey) {\n      throw new Error('User public key not found');\n    }\n\n    try {\n      // Convert X25519 public key to Ed25519 for verification (simplified)\n      // In production, you'd want separate verification keys\n      const verifyKey = publicKey; // This would need proper conversion\n      \n      return sodium.crypto_sign_verify_detached(signature, data, verifyKey);\n    } catch (error) {\n      console.error('Failed to verify signature:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Secure key derivation from password\n   */\n  deriveKeyFromPassword(\n    password: string, \n    salt: Uint8Array, \n    keyLength: number = 32\n  ): Uint8Array {\n    return sodium.crypto_pwhash(\n      keyLength,\n      password,\n      salt,\n      sodium.crypto_pwhash_OPSLIMIT_MODERATE,\n      sodium.crypto_pwhash_MEMLIMIT_MODERATE,\n      sodium.crypto_pwhash_ALG_ARGON2ID13\n    );\n  }\n\n  /**\n   * Secure memory wipe\n   */\n  secureWipe(data: Uint8Array): void {\n    sodium.memzero(data);\n  }\n\n  /**\n   * Check if biometric authentication is available\n   */\n  async isBiometricAvailable(): Promise<boolean> {\n    try {\n      const hasHardware = await LocalAuthentication.hasHardwareAsync();\n      const isEnrolled = await LocalAuthentication.isEnrolledAsync();\n      return hasHardware && isEnrolled;\n    } catch (error) {\n      console.error('Failed to check biometric availability:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Authenticate with biometrics before key access\n   */\n  async authenticateWithBiometrics(reason: string): Promise<boolean> {\n    try {\n      const result = await LocalAuthentication.authenticateAsync({\n        promptMessage: reason,\n        fallbackLabel: 'Use passcode',\n        disableDeviceFallback: false,\n      });\n      \n      return result.success;\n    } catch (error) {\n      console.error('Biometric authentication failed:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Store encrypted data with biometric protection\n   */\n  async storeBiometricProtectedData(\n    key: string, \n    data: string, \n    requireBiometric: boolean = true\n  ): Promise<void> {\n    try {\n      const options: SecureStore.SecureStoreOptions = {\n        requireAuthentication: requireBiometric,\n        authenticationPrompt: 'Authenticate to access secure data',\n      };\n      \n      await SecureStore.setItemAsync(key, data, options);\n    } catch (error) {\n      console.error('Failed to store biometric protected data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve encrypted data with biometric protection\n   */\n  async retrieveBiometricProtectedData(\n    key: string, \n    requireBiometric: boolean = true\n  ): Promise<string | null> {\n    try {\n      const options: SecureStore.SecureStoreOptions = {\n        requireAuthentication: requireBiometric,\n        authenticationPrompt: 'Authenticate to access secure data',\n      };\n      \n      return await SecureStore.getItemAsync(key, options);\n    } catch (error) {\n      console.error('Failed to retrieve biometric protected data:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Clear all stored keys and data\n   */\n  async clearAllData(): Promise<void> {\n    try {\n      // Clear in-memory data\n      this.userKeyPairs.clear();\n      this.publicKeys.clear();\n      this.sessionKeys.clear();\n      this.fileKeys.clear();\n      \n      // Clear stored keys (if current user is set)\n      if (this.currentUserId) {\n        await SecureStore.deleteItemAsync(`${this.currentUserId}:privKey`);\n      }\n      \n      this.currentUserId = null;\n    } catch (error) {\n      console.error('Failed to clear all data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get crypto service status\n   */\n  getStatus(): {\n    initialized: boolean;\n    currentUser: string | null;\n    keyPairsLoaded: number;\n    publicKeysLoaded: number;\n    sessionKeysActive: number;\n  } {\n    return {\n      initialized: this.initialized,\n      currentUser: this.currentUserId,\n      keyPairsLoaded: this.userKeyPairs.size,\n      publicKeysLoaded: this.publicKeys.size,\n      sessionKeysActive: this.sessionKeys.size,\n    };\n  }\n}\n\n// Singleton instance\nlet cryptoServiceInstance: SecureCryptoService | null = null;\n\nexport const getSecureCryptoService = (): SecureCryptoService => {\n  if (!cryptoServiceInstance) {\n    cryptoServiceInstance = new SecureCryptoService();\n  }\n  \n  return cryptoServiceInstance;\n};\n\nexport default SecureCryptoService;"