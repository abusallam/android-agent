/**\n * Tactical Integration Service\n * Integrates all standardized components into a unified tactical system\n * Implements secure architecture with libsodium encryption\n */\n\nimport { EventEmitter } from 'events';\nimport { getSecureCryptoService } from './SecureCryptoService';\nimport { getCommunicationProtocolService } from './CommunicationProtocolService';\nimport { getEmergencyResponseService } from './EmergencyResponseService';\nimport { getFileFormatService } from './FileFormatService';\nimport { getPluginArchitectureService } from './PluginArchitectureService';\nimport { getMeshNetworkService } from './MeshNetworkService';\nimport { getTileSourceService } from './TileSourceService';\nimport { getPermissionsService } from './PermissionsService';\n\nexport interface TacticalSystemConfig {\n  userId: string;\n  deviceId: string;\n  classification: 'unclassified' | 'confidential' | 'secret' | 'top-secret';\n  operationalMode: 'training' | 'exercise' | 'operational';\n  theme: 'light' | 'dark' | 'desert' | 'forest';\n  language: 'en' | 'ar';\n  encryption: {\n    enabled: boolean;\n    algorithm: 'xchacha20poly1305' | 'aes256gcm';\n    keyRotationInterval: number; // minutes\n  };\n  networking: {\n    protocols: string[];\n    meshEnabled: boolean;\n    vpnRequired: boolean;\n  };\n  emergency: {\n    manDownEnabled: boolean;\n    emergencyContacts: string[];\n    silentAlarmEnabled: boolean;\n  };\n  plugins: {\n    enabled: boolean;\n    autoUpdate: boolean;\n    trustedSources: string[];\n  };\n}\n\nexport interface TacticalSystemStatus {\n  initialized: boolean;\n  operational: boolean;\n  services: {\n    crypto: boolean;\n    communication: boolean;\n    emergency: boolean;\n    fileFormat: boolean;\n    plugins: boolean;\n    mesh: boolean;\n    tiles: boolean;\n    permissions: boolean;\n  };\n  security: {\n    encrypted: boolean;\n    authenticated: boolean;\n    keyStatus: 'valid' | 'expired' | 'missing';\n    lastKeyRotation: Date;\n  };\n  performance: {\n    memoryUsage: number;\n    cpuUsage: number;\n    networkLatency: number;\n    batteryLevel: number;\n  };\n  errors: string[];\n  warnings: string[];\n}\n\nexport interface TacticalCapabilities {\n  mapping: {\n    tileSources: string[];\n    offlineSupport: boolean;\n    layerSupport: string[];\n  };\n  communication: {\n    protocols: string[];\n    encryption: boolean;\n    meshNetworking: boolean;\n    emergencyChannels: boolean;\n  };\n  fileFormats: {\n    import: string[];\n    export: string[];\n    conversion: boolean;\n  };\n  emergency: {\n    panicButton: boolean;\n    manDownDetection: boolean;\n    casevacPlanning: boolean;\n    silentAlarm: boolean;\n  };\n  plugins: {\n    marketplace: boolean;\n    customPlugins: boolean;\n    sandboxing: boolean;\n  };\n  security: {\n    endToEndEncryption: boolean;\n    biometricAuth: boolean;\n    secureStorage: boolean;\n    keyManagement: boolean;\n  };\n}\n\n/**\n * Tactical Integration Service\n * Orchestrates all tactical services into a unified system\n */\nexport class TacticalIntegrationService extends EventEmitter {\n  private initialized = false;\n  private config: TacticalSystemConfig | null = null;\n  private status: TacticalSystemStatus;\n  \n  // Service instances\n  private cryptoService = getSecureCryptoService();\n  private communicationService = getCommunicationProtocolService();\n  private emergencyService = getEmergencyResponseService();\n  private fileFormatService = getFileFormatService();\n  private pluginService = getPluginArchitectureService();\n  private meshService = getMeshNetworkService();\n  private tileService = getTileSourceService();\n  private permissionsService = getPermissionsService();\n  \n  // System monitoring\n  private healthCheckInterval: NodeJS.Timeout | null = null;\n  private keyRotationInterval: NodeJS.Timeout | null = null;\n  private performanceMonitor: NodeJS.Timeout | null = null;\n\n  constructor() {\n    super();\n    \n    this.status = {\n      initialized: false,\n      operational: false,\n      services: {\n        crypto: false,\n        communication: false,\n        emergency: false,\n        fileFormat: false,\n        plugins: false,\n        mesh: false,\n        tiles: false,\n        permissions: false,\n      },\n      security: {\n        encrypted: false,\n        authenticated: false,\n        keyStatus: 'missing',\n        lastKeyRotation: new Date(),\n      },\n      performance: {\n        memoryUsage: 0,\n        cpuUsage: 0,\n        networkLatency: 0,\n        batteryLevel: 100,\n      },\n      errors: [],\n      warnings: [],\n    };\n  }\n\n  /**\n   * Initialize the tactical system with secure configuration\n   */\n  async initialize(config: TacticalSystemConfig): Promise<void> {\n    try {\n      this.config = config;\n      this.emit('initializationStarted', { config });\n      \n      // Phase 1: Initialize crypto service first (security foundation)\n      await this.initializeCryptoService(config);\n      \n      // Phase 2: Initialize core services\n      await this.initializeCoreServices(config);\n      \n      // Phase 3: Initialize tactical services\n      await this.initializeTacticalServices(config);\n      \n      // Phase 4: Initialize advanced services\n      await this.initializeAdvancedServices(config);\n      \n      // Phase 5: Setup system monitoring\n      await this.setupSystemMonitoring(config);\n      \n      // Phase 6: Validate system integrity\n      await this.validateSystemIntegrity();\n      \n      this.initialized = true;\n      this.status.initialized = true;\n      this.status.operational = true;\n      \n      this.emit('initialized', { \n        config, \n        status: this.status,\n        capabilities: this.getSystemCapabilities() \n      });\n    } catch (error) {\n      this.status.errors.push(error.message);\n      console.error('Failed to initialize tactical system:', error);\n      this.emit('error', { error, context: 'initialization' });\n      throw error;\n    }\n  }\n\n  /**\n   * Get current system status\n   */\n  getSystemStatus(): TacticalSystemStatus {\n    return { ...this.status };\n  }\n\n  /**\n   * Get system capabilities\n   */\n  getSystemCapabilities(): TacticalCapabilities {\n    return {\n      mapping: {\n        tileSources: ['osm', 'satellite', 'topo', 'tactical'],\n        offlineSupport: true,\n        layerSupport: ['markers', 'overlays', 'tracks', 'geofences'],\n      },\n      communication: {\n        protocols: ['websocket', 'livekit', 'matrix', 'mesh'],\n        encryption: true,\n        meshNetworking: true,\n        emergencyChannels: true,\n      },\n      fileFormats: {\n        import: ['kml', 'kmz', 'gpx', 'geojson'],\n        export: ['kml', 'kmz', 'gpx', 'geojson'],\n        conversion: true,\n      },\n      emergency: {\n        panicButton: true,\n        manDownDetection: true,\n        casevacPlanning: true,\n        silentAlarm: true,\n      },\n      plugins: {\n        marketplace: true,\n        customPlugins: true,\n        sandboxing: true,\n      },\n      security: {\n        endToEndEncryption: true,\n        biometricAuth: true,\n        secureStorage: true,\n        keyManagement: true,\n      },\n    };\n  }\n\n  /**\n   * Execute emergency protocol\n   */\n  async executeEmergencyProtocol(\n    type: 'panic' | 'medical' | 'security' | 'extraction',\n    details?: any\n  ): Promise<void> {\n    try {\n      // Trigger emergency alert\n      const alertId = await this.emergencyService.triggerEmergencyAlert(\n        type,\n        details,\n        this.config?.emergency.silentAlarmEnabled && type === 'security'\n      );\n      \n      // Broadcast emergency through all available protocols\n      await this.communicationService.broadcastEmergency({\n        type: 'emergency_protocol',\n        alertId,\n        classification: this.config?.classification || 'unclassified',\n        timestamp: new Date(),\n      });\n      \n      // Activate mesh networking for redundancy\n      if (this.config?.networking.meshEnabled) {\n        await this.meshService.broadcastMessage({\n          type: 'emergency_beacon',\n          alertId,\n          priority: 'emergency',\n        });\n      }\n      \n      this.emit('emergencyProtocolExecuted', { type, alertId });\n    } catch (error) {\n      console.error('Failed to execute emergency protocol:', error);\n      this.emit('error', { error, context: 'emergency_protocol' });\n      throw error;\n    }\n  }\n\n  /**\n   * Import tactical data from file\n   */\n  async importTacticalData(fileUri: string, filename: string): Promise<any> {\n    try {\n      // Import file using file format service\n      const importResult = await this.fileFormatService.importFromFile(fileUri, filename);\n      \n      if (!importResult.success) {\n        throw new Error(`Failed to import file: ${importResult.errors.join(', ')}`);\n      }\n      \n      // Process and validate tactical features\n      const processedFeatures = await this.processTacticalFeatures(importResult.features);\n      \n      // Encrypt sensitive data if required\n      if (this.config?.encryption.enabled) {\n        await this.encryptTacticalData(processedFeatures);\n      }\n      \n      // Broadcast data update to connected systems\n      await this.communicationService.broadcastMessage({\n        type: 'tactical_data_update',\n        features: processedFeatures.length,\n        classification: this.config?.classification || 'unclassified',\n      });\n      \n      this.emit('tacticalDataImported', { \n        filename, \n        features: processedFeatures.length,\n        format: importResult.format \n      });\n      \n      return {\n        success: true,\n        features: processedFeatures,\n        metadata: importResult.metadata,\n      };\n    } catch (error) {\n      console.error('Failed to import tactical data:', error);\n      this.emit('error', { error, context: 'data_import' });\n      throw error;\n    }\n  }\n\n  /**\n   * Export tactical data to file\n   */\n  async exportTacticalData(\n    features: any[],\n    format: string,\n    filename: string\n  ): Promise<any> {\n    try {\n      // Decrypt data if encrypted\n      let exportFeatures = features;\n      if (this.config?.encryption.enabled) {\n        exportFeatures = await this.decryptTacticalData(features);\n      }\n      \n      // Export using file format service\n      const exportResult = await this.fileFormatService.exportFeatures(\n        exportFeatures,\n        format,\n        filename\n      );\n      \n      if (!exportResult.success) {\n        throw new Error(`Failed to export file: ${exportResult.errors.join(', ')}`);\n      }\n      \n      this.emit('tacticalDataExported', { \n        filename, \n        format, \n        size: exportResult.size \n      });\n      \n      return exportResult;\n    } catch (error) {\n      console.error('Failed to export tactical data:', error);\n      this.emit('error', { error, context: 'data_export' });\n      throw error;\n    }\n  }\n\n  /**\n   * Install and activate plugin\n   */\n  async installPlugin(source: string, configuration?: any): Promise<string> {\n    try {\n      // Install plugin\n      const pluginId = await this.pluginService.installPlugin(source, {\n        configuration,\n        skipValidation: false,\n      });\n      \n      // Activate plugin\n      await this.pluginService.activatePlugin(pluginId);\n      \n      // Update system capabilities\n      this.updateSystemCapabilities();\n      \n      this.emit('pluginInstalled', { pluginId, source });\n      \n      return pluginId;\n    } catch (error) {\n      console.error('Failed to install plugin:', error);\n      this.emit('error', { error, context: 'plugin_install' });\n      throw error;\n    }\n  }\n\n  /**\n   * Rotate encryption keys\n   */\n  async rotateEncryptionKeys(): Promise<void> {\n    if (!this.config?.encryption.enabled) {\n      return;\n    }\n\n    try {\n      // Generate new keypair\n      const newPublicKey = await this.cryptoService.generateNewKeypair(this.config.userId);\n      \n      // Broadcast new public key to contacts\n      await this.communicationService.broadcastMessage({\n        type: 'key_rotation',\n        publicKey: newPublicKey,\n        timestamp: new Date(),\n      });\n      \n      // Update key status\n      this.status.security.lastKeyRotation = new Date();\n      this.status.security.keyStatus = 'valid';\n      \n      this.emit('keysRotated', { timestamp: new Date() });\n    } catch (error) {\n      console.error('Failed to rotate encryption keys:', error);\n      this.emit('error', { error, context: 'key_rotation' });\n      throw error;\n    }\n  }\n\n  /**\n   * Perform system health check\n   */\n  async performHealthCheck(): Promise<TacticalSystemStatus> {\n    try {\n      // Check all services\n      this.status.services.crypto = this.cryptoService.getStatus().initialized;\n      this.status.services.communication = Object.keys(\n        this.communicationService.getProtocolStatuses()\n      ).length > 0;\n      this.status.services.emergency = true; // Emergency service is always available\n      this.status.services.fileFormat = true; // File format service is always available\n      this.status.services.plugins = this.pluginService.getActivePlugins().length >= 0;\n      this.status.services.mesh = this.meshService.getNetworkStats() !== null;\n      this.status.services.tiles = this.tileService.getAvailableSources().length > 0;\n      this.status.services.permissions = true; // Permissions service is always available\n      \n      // Check security status\n      this.status.security.encrypted = this.config?.encryption.enabled || false;\n      this.status.security.authenticated = this.cryptoService.getStatus().currentUser !== null;\n      \n      // Update performance metrics\n      await this.updatePerformanceMetrics();\n      \n      // Clear old errors and warnings\n      this.status.errors = this.status.errors.slice(-10); // Keep last 10 errors\n      this.status.warnings = this.status.warnings.slice(-10); // Keep last 10 warnings\n      \n      this.emit('healthCheckCompleted', { status: this.status });\n      \n      return this.status;\n    } catch (error) {\n      this.status.errors.push(error.message);\n      console.error('Health check failed:', error);\n      this.emit('error', { error, context: 'health_check' });\n      return this.status;\n    }\n  }\n\n  // Private initialization methods\n  private async initializeCryptoService(config: TacticalSystemConfig): Promise<void> {\n    await this.cryptoService.initialize();\n    await this.cryptoService.initializeUserKeypair(config.userId);\n    this.status.services.crypto = true;\n    this.status.security.encrypted = config.encryption.enabled;\n    this.status.security.authenticated = true;\n    this.status.security.keyStatus = 'valid';\n  }\n\n  private async initializeCoreServices(config: TacticalSystemConfig): Promise<void> {\n    // Initialize permissions service\n    await this.permissionsService.initialize();\n    this.status.services.permissions = true;\n    \n    // Initialize tile service\n    await this.tileService.initialize();\n    this.status.services.tiles = true;\n    \n    // Initialize file format service\n    await this.fileFormatService.initialize();\n    this.status.services.fileFormat = true;\n  }\n\n  private async initializeTacticalServices(config: TacticalSystemConfig): Promise<void> {\n    // Initialize communication service\n    await this.communicationService.initialize(config.userId);\n    \n    // Activate configured protocols\n    for (const protocol of config.networking.protocols) {\n      try {\n        await this.communicationService.activateProtocol(\n          protocol,\n          `wss://tactical-server.com/${protocol}`\n        );\n      } catch (error) {\n        this.status.warnings.push(`Failed to activate protocol ${protocol}: ${error.message}`);\n      }\n    }\n    \n    this.status.services.communication = true;\n    \n    // Initialize emergency service\n    await this.emergencyService.initialize(config.userId);\n    \n    // Configure emergency settings\n    if (config.emergency.manDownEnabled) {\n      await this.emergencyService.setManDownDetection(true, {\n        sensitivity: 'medium',\n        timeout: 30,\n        confirmationRequired: true,\n      });\n    }\n    \n    this.status.services.emergency = true;\n  }\n\n  private async initializeAdvancedServices(config: TacticalSystemConfig): Promise<void> {\n    // Initialize mesh networking if enabled\n    if (config.networking.meshEnabled) {\n      try {\n        const networkId = await this.meshService.createNetwork(\n          'tactical-mesh',\n          'livekit',\n          {\n            encryption: {\n              enabled: config.encryption.enabled,\n              algorithm: 'AES-256',\n              keyRotation: config.encryption.keyRotationInterval,\n            },\n          }\n        );\n        \n        this.status.services.mesh = true;\n      } catch (error) {\n        this.status.warnings.push(`Failed to initialize mesh networking: ${error.message}`);\n      }\n    }\n    \n    // Initialize plugin service if enabled\n    if (config.plugins.enabled) {\n      await this.pluginService.initialize();\n      this.status.services.plugins = true;\n    }\n  }\n\n  private async setupSystemMonitoring(config: TacticalSystemConfig): Promise<void> {\n    // Setup health check monitoring\n    this.healthCheckInterval = setInterval(async () => {\n      await this.performHealthCheck();\n    }, 60000); // Every minute\n    \n    // Setup key rotation if encryption is enabled\n    if (config.encryption.enabled && config.encryption.keyRotationInterval > 0) {\n      this.keyRotationInterval = setInterval(async () => {\n        await this.rotateEncryptionKeys();\n      }, config.encryption.keyRotationInterval * 60 * 1000);\n    }\n    \n    // Setup performance monitoring\n    this.performanceMonitor = setInterval(async () => {\n      await this.updatePerformanceMetrics();\n    }, 30000); // Every 30 seconds\n  }\n\n  private async validateSystemIntegrity(): Promise<void> {\n    const requiredServices = ['crypto', 'permissions', 'tiles', 'fileFormat'];\n    \n    for (const service of requiredServices) {\n      if (!this.status.services[service as keyof typeof this.status.services]) {\n        throw new Error(`Critical service not initialized: ${service}`);\n      }\n    }\n    \n    // Validate encryption if enabled\n    if (this.config?.encryption.enabled) {\n      const cryptoStatus = this.cryptoService.getStatus();\n      if (!cryptoStatus.initialized || !cryptoStatus.currentUser) {\n        throw new Error('Encryption enabled but crypto service not properly initialized');\n      }\n    }\n  }\n\n  private async processTacticalFeatures(features: any[]): Promise<any[]> {\n    // Process and validate tactical features\n    return features.map(feature => ({\n      ...feature,\n      classification: this.config?.classification || 'unclassified',\n      timestamp: new Date(),\n      processed: true,\n    }));\n  }\n\n  private async encryptTacticalData(features: any[]): Promise<void> {\n    // Encrypt sensitive tactical data\n    for (const feature of features) {\n      if (feature.properties && feature.properties.sensitive) {\n        const encrypted = await this.cryptoService.encryptForRecipients(\n          JSON.stringify(feature.properties),\n          [this.config!.userId]\n        );\n        \n        feature.properties = {\n          encrypted: true,\n          data: encrypted.encryptedMessage,\n          keys: encrypted.encryptedKeys,\n        };\n      }\n    }\n  }\n\n  private async decryptTacticalData(features: any[]): Promise<any[]> {\n    // Decrypt tactical data for export\n    const decryptedFeatures = [];\n    \n    for (const feature of features) {\n      if (feature.properties && feature.properties.encrypted) {\n        try {\n          const decrypted = await this.cryptoService.decryptFromSender(\n            feature.properties.data,\n            feature.properties.keys[this.config!.userId],\n            this.config!.userId\n          );\n          \n          feature.properties = JSON.parse(decrypted);\n        } catch (error) {\n          console.error('Failed to decrypt feature:', error);\n          // Keep encrypted version if decryption fails\n        }\n      }\n      \n      decryptedFeatures.push(feature);\n    }\n    \n    return decryptedFeatures;\n  }\n\n  private updateSystemCapabilities(): void {\n    // Update system capabilities based on active plugins and services\n    this.emit('capabilitiesUpdated', { \n      capabilities: this.getSystemCapabilities() \n    });\n  }\n\n  private async updatePerformanceMetrics(): Promise<void> {\n    try {\n      // Update performance metrics (simplified implementation)\n      this.status.performance = {\n        memoryUsage: Math.random() * 100, // Mock data\n        cpuUsage: Math.random() * 50,\n        networkLatency: Math.random() * 100,\n        batteryLevel: 85, // Mock data\n      };\n    } catch (error) {\n      console.error('Failed to update performance metrics:', error);\n    }\n  }\n\n  /**\n   * Shutdown the tactical system\n   */\n  async shutdown(): Promise<void> {\n    try {\n      // Clear monitoring intervals\n      if (this.healthCheckInterval) {\n        clearInterval(this.healthCheckInterval);\n      }\n      \n      if (this.keyRotationInterval) {\n        clearInterval(this.keyRotationInterval);\n      }\n      \n      if (this.performanceMonitor) {\n        clearInterval(this.performanceMonitor);\n      }\n      \n      // Shutdown all services\n      await Promise.allSettled([\n        this.cryptoService.clearAllData(),\n        this.communicationService.cleanup(),\n        this.emergencyService.cleanup(),\n        this.fileFormatService.cleanup(),\n        this.pluginService.cleanup(),\n        this.meshService.cleanup(),\n      ]);\n      \n      // Reset status\n      this.status.initialized = false;\n      this.status.operational = false;\n      Object.keys(this.status.services).forEach(key => {\n        this.status.services[key as keyof typeof this.status.services] = false;\n      });\n      \n      this.initialized = false;\n      this.config = null;\n      \n      this.emit('shutdown');\n    } catch (error) {\n      console.error('Error during system shutdown:', error);\n      this.emit('error', { error, context: 'shutdown' });\n    }\n  }\n}\n\n// Singleton instance\nlet tacticalSystemInstance: TacticalIntegrationService | null = null;\n\nexport const getTacticalIntegrationService = (): TacticalIntegrationService => {\n  if (!tacticalSystemInstance) {\n    tacticalSystemInstance = new TacticalIntegrationService();\n  }\n  \n  return tacticalSystemInstance;\n};\n\nexport default TacticalIntegrationService;"