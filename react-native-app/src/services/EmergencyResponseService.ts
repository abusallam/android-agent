/**\n * Emergency Response Service\n * Implements ATAK Feature #6 - Emergency Response System\n * Provides one-touch emergency beacon, man-down detection, and CASEVAC planning\n */\n\nimport { EventEmitter } from 'events';\nimport * as Location from 'expo-location';\nimport * as Sensors from 'expo-sensors';\nimport * as Notifications from 'expo-notifications';\nimport { getCommunicationProtocolService } from './CommunicationProtocolService';\nimport { getSecureCryptoService } from './SecureCryptoService';\n\nexport interface EmergencyContact {\n  id: string;\n  name: string;\n  role: 'commander' | 'medic' | 'support' | 'family' | 'emergency_services';\n  priority: 'primary' | 'secondary' | 'tertiary';\n  contact: {\n    phone?: string;\n    radio?: string;\n    email?: string;\n    callSign?: string;\n  };\n  location?: {\n    lat: number;\n    lng: number;\n    accuracy?: number;\n    timestamp: Date;\n  };\n  capabilities: string[]; // ['medical', 'extraction', 'command', 'logistics']\n  availability: 'available' | 'busy' | 'offline' | 'unknown';\n  responseTime: number; // estimated response time in minutes\n}\n\nexport interface EmergencyAlert {\n  id: string;\n  type: 'panic' | 'medical' | 'man_down' | 'extraction' | 'fire' | 'security' | 'custom';\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  status: 'active' | 'acknowledged' | 'responding' | 'resolved' | 'cancelled' | 'false_alarm';\n  classification: 'unclassified' | 'confidential' | 'secret' | 'top-secret';\n  \n  // Reporter information\n  reporter: {\n    userId: string;\n    name: string;\n    callSign?: string;\n    unitId?: string;\n  };\n  \n  // Location and context\n  location: {\n    lat: number;\n    lng: number;\n    accuracy: number;\n    altitude?: number;\n    heading?: number;\n    speed?: number;\n    timestamp: Date;\n    address?: string;\n  };\n  \n  // Emergency details\n  details: {\n    title: string;\n    description: string;\n    casualties?: {\n      total: number;\n      urgent: number;\n      priority: number;\n      routine: number;\n      deceased: number;\n    };\n    resources?: {\n      medical: boolean;\n      extraction: boolean;\n      fire: boolean;\n      security: boolean;\n      logistics: boolean;\n    };\n    hazards?: string[];\n    instructions?: string[];\n    equipment?: string[];\n  };\n  \n  // Response tracking\n  response: {\n    acknowledged: boolean;\n    acknowledgedBy?: string;\n    acknowledgedAt?: Date;\n    responders: Array<{\n      contactId: string;\n      status: 'notified' | 'acknowledged' | 'en_route' | 'on_scene' | 'completed';\n      eta?: Date;\n      location?: {\n        lat: number;\n        lng: number;\n        timestamp: Date;\n      };\n    }>;\n    resources: {\n      dispatched: string[];\n      requested: string[];\n      available: string[];\n    };\n  };\n  \n  // Timeline\n  timeline: Array<{\n    timestamp: Date;\n    event: string;\n    user?: string;\n    details?: string;\n    location?: {\n      lat: number;\n      lng: number;\n    };\n  }>;\n  \n  // Metadata\n  created: Date;\n  updated: Date;\n  expiresAt?: Date;\n  silent: boolean; // for covert operations\n  encrypted: boolean;\n}\n\nexport interface ManDownDetection {\n  enabled: boolean;\n  sensitivity: 'low' | 'medium' | 'high';\n  timeout: number; // seconds before alert\n  confirmationRequired: boolean;\n  accelerometerThreshold: number;\n  gyroscopeThreshold: number;\n  motionlessTimeout: number; // seconds of no motion\n  heartRateMonitoring: boolean;\n  lastMovement: Date;\n  currentStatus: 'normal' | 'suspicious' | 'alert' | 'emergency';\n}\n\nexport interface CASEVACPlan {\n  id: string;\n  patientId: string;\n  priority: 'urgent' | 'priority' | 'routine';\n  medicalCategory: 'A' | 'B' | 'C' | 'D'; // NATO medical categories\n  \n  // Patient information\n  patient: {\n    name: string;\n    age?: number;\n    bloodType?: string;\n    allergies?: string[];\n    medications?: string[];\n    medicalHistory?: string[];\n    injuries: Array<{\n      type: string;\n      severity: 'minor' | 'moderate' | 'severe' | 'critical';\n      bodyPart: string;\n      description: string;\n      treatment: string[];\n    }>;\n    vitals?: {\n      pulse?: number;\n      bloodPressure?: string;\n      temperature?: number;\n      respiratoryRate?: number;\n      oxygenSaturation?: number;\n      consciousness: 'alert' | 'verbal' | 'pain' | 'unresponsive';\n      timestamp: Date;\n    };\n  };\n  \n  // Evacuation details\n  evacuation: {\n    pickupLocation: {\n      lat: number;\n      lng: number;\n      description: string;\n      landingZone?: {\n        size: string;\n        obstacles: string[];\n        lighting: boolean;\n        marking: string;\n      };\n    };\n    destination: {\n      facility: string;\n      type: 'aid_station' | 'field_hospital' | 'civilian_hospital' | 'trauma_center';\n      capabilities: string[];\n      eta?: Date;\n      contact: string;\n    };\n    transport: {\n      method: 'ground' | 'air' | 'water';\n      vehicle?: string;\n      crew: string[];\n      equipment: string[];\n      eta?: Date;\n    };\n  };\n  \n  // Status tracking\n  status: 'planning' | 'requested' | 'approved' | 'dispatched' | 'en_route' | 'completed' | 'cancelled';\n  timeline: Array<{\n    timestamp: Date;\n    event: string;\n    user: string;\n    details?: string;\n  }>;\n  \n  created: Date;\n  updated: Date;\n  createdBy: string;\n}\n\nexport interface DistressSignal {\n  id: string;\n  type: 'manual' | 'automatic' | 'man_down' | 'panic' | 'duress';\n  status: 'active' | 'acknowledged' | 'resolved' | 'false_alarm';\n  \n  // Signal details\n  signal: {\n    frequency?: string;\n    power?: number;\n    duration: number;\n    interval: number;\n    pattern: 'continuous' | 'intermittent' | 'morse' | 'custom';\n    encrypted: boolean;\n  };\n  \n  // Location tracking\n  location: {\n    lat: number;\n    lng: number;\n    accuracy: number;\n    timestamp: Date;\n    tracking: boolean; // continuous location updates\n  };\n  \n  // Sender information\n  sender: {\n    userId: string;\n    deviceId: string;\n    callSign?: string;\n    unitId?: string;\n  };\n  \n  // Trigger information\n  trigger: {\n    method: 'button' | 'sensor' | 'timeout' | 'geofence' | 'biometric';\n    timestamp: Date;\n    confidence: number; // 0-1\n    sensorData?: any;\n  };\n  \n  // Escalation\n  escalation: {\n    level: number;\n    maxLevel: number;\n    nextEscalation?: Date;\n    contacts: string[];\n    automated: boolean;\n  };\n  \n  created: Date;\n  lastUpdate: Date;\n}\n\n/**\n * Emergency Response Service\n * Handles all emergency response functionality\n */\nexport class EmergencyResponseService extends EventEmitter {\n  private initialized = false;\n  private currentUserId: string | null = null;\n  private emergencyContacts: Map<string, EmergencyContact> = new Map();\n  private activeAlerts: Map<string, EmergencyAlert> = new Map();\n  private casevacPlans: Map<string, CASEVACPlan> = new Map();\n  private distressSignals: Map<string, DistressSignal> = new Map();\n  \n  // Man-down detection\n  private manDownDetection: ManDownDetection = {\n    enabled: false,\n    sensitivity: 'medium',\n    timeout: 30,\n    confirmationRequired: true,\n    accelerometerThreshold: 2.5,\n    gyroscopeThreshold: 1.0,\n    motionlessTimeout: 300, // 5 minutes\n    heartRateMonitoring: false,\n    lastMovement: new Date(),\n    currentStatus: 'normal',\n  };\n  \n  // Sensor subscriptions\n  private accelerometerSubscription: any = null;\n  private gyroscopeSubscription: any = null;\n  private locationSubscription: any = null;\n  private manDownTimer: NodeJS.Timeout | null = null;\n  private heartbeatTimer: NodeJS.Timeout | null = null;\n  \n  // Services\n  private communicationService = getCommunicationProtocolService();\n  private cryptoService = getSecureCryptoService();\n\n  constructor() {\n    super();\n  }\n\n  /**\n   * Initialize the emergency response service\n   */\n  async initialize(userId: string): Promise<void> {\n    try {\n      this.currentUserId = userId;\n      \n      // Initialize communication and crypto services\n      await this.communicationService.initialize(userId);\n      await this.cryptoService.initialize();\n      \n      // Load emergency contacts\n      await this.loadEmergencyContacts();\n      \n      // Set up notifications\n      await this.setupNotifications();\n      \n      // Initialize sensors for man-down detection\n      await this.initializeSensors();\n      \n      // Start heartbeat monitoring\n      this.startHeartbeatMonitoring();\n      \n      this.initialized = true;\n      this.emit('initialized', { userId });\n    } catch (error) {\n      console.error('Failed to initialize emergency response service:', error);\n      this.emit('error', { error, context: 'initialization' });\n      throw error;\n    }\n  }\n\n  /**\n   * Trigger emergency alert (one-touch emergency beacon)\n   */\n  async triggerEmergencyAlert(\n    type: EmergencyAlert['type'],\n    details: Partial<EmergencyAlert['details']>,\n    silent: boolean = false\n  ): Promise<string> {\n    if (!this.initialized || !this.currentUserId) {\n      throw new Error('Service not initialized');\n    }\n\n    try {\n      // Get current location\n      const location = await this.getCurrentLocation();\n      \n      // Create emergency alert\n      const alert: EmergencyAlert = {\n        id: this.generateAlertId(),\n        type,\n        severity: this.determineSeverity(type),\n        status: 'active',\n        classification: 'unclassified',\n        reporter: {\n          userId: this.currentUserId,\n          name: 'Current User', // Would get from user profile\n          callSign: 'UNKNOWN',\n        },\n        location,\n        details: {\n          title: this.getDefaultTitle(type),\n          description: details.description || 'Emergency alert triggered',\n          ...details,\n        },\n        response: {\n          acknowledged: false,\n          responders: [],\n          resources: {\n            dispatched: [],\n            requested: [],\n            available: [],\n          },\n        },\n        timeline: [{\n          timestamp: new Date(),\n          event: 'Emergency alert created',\n          user: this.currentUserId,\n          details: `${type} alert triggered`,\n          location: {\n            lat: location.lat,\n            lng: location.lng,\n          },\n        }],\n        created: new Date(),\n        updated: new Date(),\n        silent,\n        encrypted: true,\n      };\n      \n      // Store alert\n      this.activeAlerts.set(alert.id, alert);\n      \n      // Send alert to emergency contacts\n      await this.notifyEmergencyContacts(alert);\n      \n      // Send distress signal if not silent\n      if (!silent) {\n        await this.sendDistressSignal(alert);\n      }\n      \n      // Show local notification\n      await this.showEmergencyNotification(alert);\n      \n      this.emit('emergencyAlertTriggered', { alert });\n      \n      return alert.id;\n    } catch (error) {\n      console.error('Failed to trigger emergency alert:', error);\n      this.emit('error', { error, context: 'emergency_alert' });\n      throw error;\n    }\n  }\n\n  /**\n   * Enable/disable man-down detection\n   */\n  async setManDownDetection(enabled: boolean, config?: Partial<ManDownDetection>): Promise<void> {\n    try {\n      this.manDownDetection = {\n        ...this.manDownDetection,\n        enabled,\n        ...config,\n      };\n      \n      if (enabled) {\n        await this.startManDownMonitoring();\n      } else {\n        this.stopManDownMonitoring();\n      }\n      \n      this.emit('manDownDetectionChanged', { \n        enabled, \n        config: this.manDownDetection \n      });\n    } catch (error) {\n      console.error('Failed to set man-down detection:', error);\n      this.emit('error', { error, context: 'man_down_detection' });\n      throw error;\n    }\n  }\n\n  /**\n   * Create CASEVAC plan\n   */\n  async createCASEVACPlan(\n    patientInfo: CASEVACPlan['patient'],\n    priority: CASEVACPlan['priority']\n  ): Promise<string> {\n    if (!this.initialized || !this.currentUserId) {\n      throw new Error('Service not initialized');\n    }\n\n    try {\n      const location = await this.getCurrentLocation();\n      \n      const plan: CASEVACPlan = {\n        id: this.generateCASEVACId(),\n        patientId: this.generatePatientId(),\n        priority,\n        medicalCategory: this.determineMedicalCategory(patientInfo.injuries),\n        patient: patientInfo,\n        evacuation: {\n          pickupLocation: {\n            lat: location.lat,\n            lng: location.lng,\n            description: 'Current location',\n          },\n          destination: {\n            facility: 'TBD',\n            type: 'field_hospital',\n            capabilities: [],\n            contact: 'TBD',\n          },\n          transport: {\n            method: 'air',\n            crew: [],\n            equipment: [],\n          },\n        },\n        status: 'planning',\n        timeline: [{\n          timestamp: new Date(),\n          event: 'CASEVAC plan created',\n          user: this.currentUserId,\n        }],\n        created: new Date(),\n        updated: new Date(),\n        createdBy: this.currentUserId,\n      };\n      \n      this.casevacPlans.set(plan.id, plan);\n      \n      // Notify medical personnel\n      await this.notifyMedicalPersonnel(plan);\n      \n      this.emit('casevacPlanCreated', { plan });\n      \n      return plan.id;\n    } catch (error) {\n      console.error('Failed to create CASEVAC plan:', error);\n      this.emit('error', { error, context: 'casevac_plan' });\n      throw error;\n    }\n  }\n\n  /**\n   * Add emergency contact\n   */\n  async addEmergencyContact(contact: Omit<EmergencyContact, 'id'>): Promise<string> {\n    const contactId = this.generateContactId();\n    const fullContact: EmergencyContact = {\n      ...contact,\n      id: contactId,\n    };\n    \n    this.emergencyContacts.set(contactId, fullContact);\n    \n    // Save to persistent storage\n    await this.saveEmergencyContacts();\n    \n    this.emit('emergencyContactAdded', { contact: fullContact });\n    \n    return contactId;\n  }\n\n  /**\n   * Send silent alarm (covert operations)\n   */\n  async sendSilentAlarm(\n    type: 'duress' | 'compromise' | 'extraction',\n    details?: string\n  ): Promise<string> {\n    return await this.triggerEmergencyAlert(\n      'security',\n      {\n        title: 'Silent Alarm',\n        description: details || 'Silent alarm activated',\n      },\n      true // silent = true\n    );\n  }\n\n  /**\n   * Get active emergency alerts\n   */\n  getActiveAlerts(): EmergencyAlert[] {\n    return Array.from(this.activeAlerts.values())\n      .filter(alert => alert.status === 'active');\n  }\n\n  /**\n   * Get emergency contacts by role\n   */\n  getEmergencyContactsByRole(role: EmergencyContact['role']): EmergencyContact[] {\n    return Array.from(this.emergencyContacts.values())\n      .filter(contact => contact.role === role);\n  }\n\n  /**\n   * Get CASEVAC plans\n   */\n  getCASEVACPlans(status?: CASEVACPlan['status']): CASEVACPlan[] {\n    const plans = Array.from(this.casevacPlans.values());\n    return status ? plans.filter(plan => plan.status === status) : plans;\n  }\n\n  /**\n   * Acknowledge emergency alert\n   */\n  async acknowledgeAlert(alertId: string, responderId: string): Promise<void> {\n    const alert = this.activeAlerts.get(alertId);\n    \n    if (!alert) {\n      throw new Error('Alert not found');\n    }\n\n    alert.response.acknowledged = true;\n    alert.response.acknowledgedBy = responderId;\n    alert.response.acknowledgedAt = new Date();\n    alert.updated = new Date();\n    \n    alert.timeline.push({\n      timestamp: new Date(),\n      event: 'Alert acknowledged',\n      user: responderId,\n    });\n    \n    this.emit('alertAcknowledged', { alertId, responderId });\n  }\n\n  // Private methods\n  private async getCurrentLocation(): Promise<EmergencyAlert['location']> {\n    try {\n      const location = await Location.getCurrentPositionAsync({\n        accuracy: Location.Accuracy.BestForNavigation,\n      });\n      \n      return {\n        lat: location.coords.latitude,\n        lng: location.coords.longitude,\n        accuracy: location.coords.accuracy || 0,\n        altitude: location.coords.altitude || undefined,\n        heading: location.coords.heading || undefined,\n        speed: location.coords.speed || undefined,\n        timestamp: new Date(location.timestamp),\n      };\n    } catch (error) {\n      console.error('Failed to get current location:', error);\n      // Return default location if GPS fails\n      return {\n        lat: 0,\n        lng: 0,\n        accuracy: 0,\n        timestamp: new Date(),\n      };\n    }\n  }\n\n  private async loadEmergencyContacts(): Promise<void> {\n    // Implementation would load from secure storage\n    // For now, add some default contacts\n    const defaultContacts: Omit<EmergencyContact, 'id'>[] = [\n      {\n        name: 'Command Center',\n        role: 'commander',\n        priority: 'primary',\n        contact: {\n          radio: 'CMD-1',\n          callSign: 'COMMAND',\n        },\n        capabilities: ['command', 'coordination'],\n        availability: 'available',\n        responseTime: 5,\n      },\n      {\n        name: 'Medical Team',\n        role: 'medic',\n        priority: 'primary',\n        contact: {\n          radio: 'MED-1',\n          callSign: 'MEDIC',\n        },\n        capabilities: ['medical', 'extraction'],\n        availability: 'available',\n        responseTime: 10,\n      },\n    ];\n    \n    for (const contact of defaultContacts) {\n      await this.addEmergencyContact(contact);\n    }\n  }\n\n  private async saveEmergencyContacts(): Promise<void> {\n    // Implementation would save to secure storage\n  }\n\n  private async setupNotifications(): Promise<void> {\n    await Notifications.setNotificationHandler({\n      handleNotification: async () => ({\n        shouldShowAlert: true,\n        shouldPlaySound: true,\n        shouldSetBadge: true,\n      }),\n    });\n  }\n\n  private async initializeSensors(): Promise<void> {\n    try {\n      // Check sensor availability\n      const accelerometerAvailable = await Sensors.Accelerometer.isAvailableAsync();\n      const gyroscopeAvailable = await Sensors.Gyroscope.isAvailableAsync();\n      \n      if (!accelerometerAvailable || !gyroscopeAvailable) {\n        console.warn('Required sensors not available for man-down detection');\n        return;\n      }\n      \n      // Set update intervals\n      Sensors.Accelerometer.setUpdateInterval(1000); // 1 second\n      Sensors.Gyroscope.setUpdateInterval(1000);\n    } catch (error) {\n      console.error('Failed to initialize sensors:', error);\n    }\n  }\n\n  private async startManDownMonitoring(): Promise<void> {\n    if (!this.manDownDetection.enabled) {\n      return;\n    }\n\n    try {\n      // Subscribe to accelerometer\n      this.accelerometerSubscription = Sensors.Accelerometer.addListener(data => {\n        this.processAccelerometerData(data);\n      });\n      \n      // Subscribe to gyroscope\n      this.gyroscopeSubscription = Sensors.Gyroscope.addListener(data => {\n        this.processGyroscopeData(data);\n      });\n      \n      // Start motion monitoring timer\n      this.startMotionMonitoring();\n    } catch (error) {\n      console.error('Failed to start man-down monitoring:', error);\n    }\n  }\n\n  private stopManDownMonitoring(): void {\n    if (this.accelerometerSubscription) {\n      this.accelerometerSubscription.remove();\n      this.accelerometerSubscription = null;\n    }\n    \n    if (this.gyroscopeSubscription) {\n      this.gyroscopeSubscription.remove();\n      this.gyroscopeSubscription = null;\n    }\n    \n    if (this.manDownTimer) {\n      clearTimeout(this.manDownTimer);\n      this.manDownTimer = null;\n    }\n  }\n\n  private processAccelerometerData(data: any): void {\n    const magnitude = Math.sqrt(data.x * data.x + data.y * data.y + data.z * data.z);\n    \n    if (magnitude > this.manDownDetection.accelerometerThreshold) {\n      this.manDownDetection.lastMovement = new Date();\n      this.updateManDownStatus('normal');\n    }\n  }\n\n  private processGyroscopeData(data: any): void {\n    const magnitude = Math.sqrt(data.x * data.x + data.y * data.y + data.z * data.z);\n    \n    if (magnitude > this.manDownDetection.gyroscopeThreshold) {\n      this.manDownDetection.lastMovement = new Date();\n      this.updateManDownStatus('normal');\n    }\n  }\n\n  private startMotionMonitoring(): void {\n    const checkInterval = 10000; // 10 seconds\n    \n    const checkMotion = () => {\n      const now = new Date();\n      const timeSinceMovement = now.getTime() - this.manDownDetection.lastMovement.getTime();\n      \n      if (timeSinceMovement > this.manDownDetection.motionlessTimeout * 1000) {\n        this.handlePotentialManDown();\n      }\n      \n      // Schedule next check\n      setTimeout(checkMotion, checkInterval);\n    };\n    \n    setTimeout(checkMotion, checkInterval);\n  }\n\n  private async handlePotentialManDown(): Promise<void> {\n    this.updateManDownStatus('alert');\n    \n    if (this.manDownDetection.confirmationRequired) {\n      // Show confirmation dialog\n      await this.showManDownConfirmation();\n    } else {\n      // Automatically trigger emergency alert\n      await this.triggerEmergencyAlert('man_down', {\n        title: 'Man Down Detected',\n        description: 'Automatic man-down detection triggered',\n      });\n    }\n  }\n\n  private async showManDownConfirmation(): Promise<void> {\n    // Implementation would show native alert dialog\n    // For now, emit event for UI to handle\n    this.emit('manDownConfirmationRequired', {\n      timeout: this.manDownDetection.timeout,\n    });\n    \n    // Set timeout for automatic alert\n    this.manDownTimer = setTimeout(async () => {\n      await this.triggerEmergencyAlert('man_down', {\n        title: 'Man Down Confirmed',\n        description: 'No response to man-down confirmation',\n      });\n    }, this.manDownDetection.timeout * 1000);\n  }\n\n  private updateManDownStatus(status: ManDownDetection['currentStatus']): void {\n    if (this.manDownDetection.currentStatus !== status) {\n      this.manDownDetection.currentStatus = status;\n      this.emit('manDownStatusChanged', { status });\n    }\n  }\n\n  private async notifyEmergencyContacts(alert: EmergencyAlert): Promise<void> {\n    const contacts = Array.from(this.emergencyContacts.values())\n      .filter(contact => contact.availability === 'available')\n      .sort((a, b) => {\n        const priorityOrder = { primary: 0, secondary: 1, tertiary: 2 };\n        return priorityOrder[a.priority] - priorityOrder[b.priority];\n      });\n    \n    for (const contact of contacts) {\n      try {\n        await this.communicationService.sendSecureMessage({\n          type: 'emergency',\n          destination: contact.id,\n          payload: {\n            content: JSON.stringify({\n              type: 'emergency_alert',\n              alert,\n            }),\n            metadata: {\n              priority: 'emergency',\n              classification: alert.classification,\n            },\n          },\n          priority: 'emergency',\n          classification: alert.classification,\n          requiresAck: true,\n          retryCount: 0,\n          maxRetries: 3,\n        });\n      } catch (error) {\n        console.error(`Failed to notify contact ${contact.name}:`, error);\n      }\n    }\n  }\n\n  private async sendDistressSignal(alert: EmergencyAlert): Promise<void> {\n    const signal: DistressSignal = {\n      id: this.generateSignalId(),\n      type: 'automatic',\n      status: 'active',\n      signal: {\n        duration: 30,\n        interval: 60,\n        pattern: 'intermittent',\n        encrypted: true,\n      },\n      location: {\n        lat: alert.location.lat,\n        lng: alert.location.lng,\n        accuracy: alert.location.accuracy,\n        timestamp: alert.location.timestamp,\n        tracking: true,\n      },\n      sender: {\n        userId: alert.reporter.userId,\n        deviceId: 'current-device',\n        callSign: alert.reporter.callSign,\n        unitId: alert.reporter.unitId,\n      },\n      trigger: {\n        method: 'button',\n        timestamp: new Date(),\n        confidence: 1.0,\n      },\n      escalation: {\n        level: 1,\n        maxLevel: 3,\n        contacts: Array.from(this.emergencyContacts.keys()),\n        automated: true,\n      },\n      created: new Date(),\n      lastUpdate: new Date(),\n    };\n    \n    this.distressSignals.set(signal.id, signal);\n    \n    // Broadcast distress signal\n    await this.communicationService.broadcastEmergency({\n      type: 'distress_signal',\n      signal,\n      alert,\n    }, alert.classification);\n  }\n\n  private async showEmergencyNotification(alert: EmergencyAlert): Promise<void> {\n    await Notifications.scheduleNotificationAsync({\n      content: {\n        title: '🚨 Emergency Alert',\n        body: `${alert.type.toUpperCase()}: ${alert.details.title}`,\n        data: { alertId: alert.id },\n        priority: Notifications.AndroidNotificationPriority.MAX,\n        sound: 'default',\n        vibrate: [0, 250, 250, 250],\n      },\n      trigger: null, // Show immediately\n    });\n  }\n\n  private async notifyMedicalPersonnel(plan: CASEVACPlan): Promise<void> {\n    const medicalContacts = this.getEmergencyContactsByRole('medic');\n    \n    for (const contact of medicalContacts) {\n      try {\n        await this.communicationService.sendSecureMessage({\n          type: 'data',\n          destination: contact.id,\n          payload: {\n            content: JSON.stringify({\n              type: 'casevac_plan',\n              plan,\n            }),\n            metadata: {\n              priority: 'high',\n              classification: 'unclassified',\n            },\n          },\n          priority: 'high',\n          classification: 'unclassified',\n          requiresAck: true,\n          retryCount: 0,\n          maxRetries: 2,\n        });\n      } catch (error) {\n        console.error(`Failed to notify medical contact ${contact.name}:`, error);\n      }\n    }\n  }\n\n  private startHeartbeatMonitoring(): void {\n    // Send periodic heartbeat to indicate system is operational\n    this.heartbeatTimer = setInterval(async () => {\n      if (this.initialized) {\n        this.emit('heartbeat', {\n          timestamp: new Date(),\n          status: 'operational',\n          manDownStatus: this.manDownDetection.currentStatus,\n          activeAlerts: this.activeAlerts.size,\n        });\n      }\n    }, 60000); // Every minute\n  }\n\n  private determineSeverity(type: EmergencyAlert['type']): EmergencyAlert['severity'] {\n    const severityMap: Record<EmergencyAlert['type'], EmergencyAlert['severity']> = {\n      panic: 'critical',\n      medical: 'high',\n      man_down: 'critical',\n      extraction: 'high',\n      fire: 'high',\n      security: 'medium',\n      custom: 'medium',\n    };\n    \n    return severityMap[type] || 'medium';\n  }\n\n  private getDefaultTitle(type: EmergencyAlert['type']): string {\n    const titleMap: Record<EmergencyAlert['type'], string> = {\n      panic: 'Panic Button Activated',\n      medical: 'Medical Emergency',\n      man_down: 'Man Down Detected',\n      extraction: 'Extraction Required',\n      fire: 'Fire Emergency',\n      security: 'Security Incident',\n      custom: 'Emergency Alert',\n    };\n    \n    return titleMap[type] || 'Emergency Alert';\n  }\n\n  private determineMedicalCategory(injuries: CASEVACPlan['patient']['injuries']): CASEVACPlan['medicalCategory'] {\n    const hasCritical = injuries.some(injury => injury.severity === 'critical');\n    const hasSevere = injuries.some(injury => injury.severity === 'severe');\n    \n    if (hasCritical) return 'A'; // Urgent\n    if (hasSevere) return 'B'; // Priority\n    return 'C'; // Routine\n  }\n\n  private generateAlertId(): string {\n    return `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateCASEVACId(): string {\n    return `casevac_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generatePatientId(): string {\n    return `patient_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateContactId(): string {\n    return `contact_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateSignalId(): string {\n    return `signal_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Cleanup resources\n   */\n  async cleanup(): Promise<void> {\n    this.stopManDownMonitoring();\n    \n    if (this.heartbeatTimer) {\n      clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = null;\n    }\n    \n    if (this.locationSubscription) {\n      this.locationSubscription.remove();\n      this.locationSubscription = null;\n    }\n    \n    this.emergencyContacts.clear();\n    this.activeAlerts.clear();\n    this.casevacPlans.clear();\n    this.distressSignals.clear();\n    \n    this.removeAllListeners();\n    this.initialized = false;\n  }\n}\n\n// Singleton instance\nlet emergencyServiceInstance: EmergencyResponseService | null = null;\n\nexport const getEmergencyResponseService = (): EmergencyResponseService => {\n  if (!emergencyServiceInstance) {\n    emergencyServiceInstance = new EmergencyResponseService();\n  }\n  \n  return emergencyServiceInstance;\n};\n\nexport default EmergencyResponseService;"