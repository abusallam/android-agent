/**\n * File Format Service\n * Implements ATAK Feature #1 - Essential File Format Support\n * Supports KML/KMZ, GPX, Shapefile import/export for tactical interoperability\n */\n\nimport { EventEmitter } from 'events';\nimport * as FileSystem from 'expo-file-system';\nimport * as DocumentPicker from 'expo-document-picker';\nimport JSZip from 'jszip';\n\n// File format interfaces\nexport interface FileFormatSupport {\n  extension: string;\n  mimeType: string;\n  name: string;\n  description: string;\n  canImport: boolean;\n  canExport: boolean;\n  features: string[];\n}\n\nexport interface ImportResult {\n  success: boolean;\n  format: string;\n  features: TacticalFeature[];\n  errors: string[];\n  warnings: string[];\n  metadata: {\n    filename: string;\n    size: number;\n    featureCount: number;\n    bounds?: {\n      north: number;\n      south: number;\n      east: number;\n      west: number;\n    };\n  };\n}\n\nexport interface ExportResult {\n  success: boolean;\n  format: string;\n  filename: string;\n  size: number;\n  path: string;\n  errors: string[];\n}\n\nexport interface TacticalFeature {\n  id: string;\n  type: 'point' | 'line' | 'polygon' | 'track' | 'route' | 'overlay';\n  name: string;\n  description?: string;\n  geometry: {\n    type: 'Point' | 'LineString' | 'Polygon' | 'MultiPoint' | 'MultiLineString' | 'MultiPolygon';\n    coordinates: number[] | number[][] | number[][][];\n  };\n  properties: {\n    classification?: 'unclassified' | 'confidential' | 'secret' | 'top-secret';\n    category?: string;\n    subcategory?: string;\n    color?: string;\n    icon?: string;\n    timestamp?: Date;\n    elevation?: number;\n    speed?: number;\n    heading?: number;\n    accuracy?: number;\n    [key: string]: any;\n  };\n  style?: {\n    stroke?: {\n      color: string;\n      width: number;\n      opacity: number;\n      dashArray?: string;\n    };\n    fill?: {\n      color: string;\n      opacity: number;\n    };\n    marker?: {\n      icon: string;\n      size: number;\n      color: string;\n    };\n  };\n}\n\nexport interface KMLDocument {\n  name: string;\n  description?: string;\n  features: TacticalFeature[];\n  folders: KMLFolder[];\n  styles: Record<string, any>;\n  metadata: {\n    created?: Date;\n    modified?: Date;\n    author?: string;\n    version?: string;\n  };\n}\n\nexport interface KMLFolder {\n  name: string;\n  description?: string;\n  features: TacticalFeature[];\n  folders: KMLFolder[];\n  visibility: boolean;\n}\n\nexport interface GPXTrack {\n  name: string;\n  description?: string;\n  segments: GPXTrackSegment[];\n  type?: string;\n  classification?: string;\n}\n\nexport interface GPXTrackSegment {\n  points: GPXTrackPoint[];\n}\n\nexport interface GPXTrackPoint {\n  lat: number;\n  lng: number;\n  elevation?: number;\n  time?: Date;\n  speed?: number;\n  heading?: number;\n  accuracy?: number;\n}\n\nexport interface GPXWaypoint {\n  lat: number;\n  lng: number;\n  name: string;\n  description?: string;\n  symbol?: string;\n  type?: string;\n  elevation?: number;\n  time?: Date;\n}\n\nexport interface GPXRoute {\n  name: string;\n  description?: string;\n  points: GPXWaypoint[];\n  type?: string;\n}\n\nexport interface ShapefileData {\n  features: TacticalFeature[];\n  projection: string;\n  bounds: {\n    minX: number;\n    minY: number;\n    maxX: number;\n    maxY: number;\n  };\n  metadata: {\n    recordCount: number;\n    shapeType: string;\n    fields: Array<{\n      name: string;\n      type: string;\n      length: number;\n    }>;\n  };\n}\n\n/**\n * File Format Service\n * Handles import/export of tactical file formats\n */\nexport class FileFormatService extends EventEmitter {\n  private supportedFormats: Map<string, FileFormatSupport> = new Map();\n  private initialized = false;\n\n  constructor() {\n    super();\n    this.initializeSupportedFormats();\n  }\n\n  /**\n   * Initialize the file format service\n   */\n  async initialize(): Promise<void> {\n    try {\n      this.initialized = true;\n      this.emit('initialized');\n    } catch (error) {\n      console.error('Failed to initialize file format service:', error);\n      this.emit('error', { error, context: 'initialization' });\n      throw error;\n    }\n  }\n\n  /**\n   * Get supported file formats\n   */\n  getSupportedFormats(): FileFormatSupport[] {\n    return Array.from(this.supportedFormats.values());\n  }\n\n  /**\n   * Check if format is supported\n   */\n  isFormatSupported(extension: string): boolean {\n    return this.supportedFormats.has(extension.toLowerCase());\n  }\n\n  /**\n   * Import file from device\n   */\n  async importFile(): Promise<ImportResult | null> {\n    try {\n      const result = await DocumentPicker.getDocumentAsync({\n        type: [\n          'application/vnd.google-earth.kml+xml',\n          'application/vnd.google-earth.kmz',\n          'application/gpx+xml',\n          'application/x-shapefile',\n          '*/*'\n        ],\n        copyToCacheDirectory: true,\n      });\n\n      if (result.canceled) {\n        return null;\n      }\n\n      const file = result.assets[0];\n      return await this.importFromFile(file.uri, file.name);\n    } catch (error) {\n      console.error('Failed to import file:', error);\n      this.emit('error', { error, context: 'import' });\n      throw error;\n    }\n  }\n\n  /**\n   * Import from file URI\n   */\n  async importFromFile(uri: string, filename: string): Promise<ImportResult> {\n    const extension = this.getFileExtension(filename);\n    const format = this.supportedFormats.get(extension);\n\n    if (!format || !format.canImport) {\n      throw new Error(`Unsupported file format: ${extension}`);\n    }\n\n    try {\n      let result: ImportResult;\n\n      switch (extension) {\n        case 'kml':\n          result = await this.importKML(uri, filename);\n          break;\n        case 'kmz':\n          result = await this.importKMZ(uri, filename);\n          break;\n        case 'gpx':\n          result = await this.importGPX(uri, filename);\n          break;\n        case 'shp':\n          result = await this.importShapefile(uri, filename);\n          break;\n        default:\n          throw new Error(`Import not implemented for ${extension}`);\n      }\n\n      this.emit('fileImported', { result, filename });\n      return result;\n    } catch (error) {\n      console.error(`Failed to import ${extension} file:`, error);\n      this.emit('error', { error, context: 'import', format: extension });\n      throw error;\n    }\n  }\n\n  /**\n   * Export features to file\n   */\n  async exportFeatures(\n    features: TacticalFeature[],\n    format: string,\n    filename: string,\n    options?: any\n  ): Promise<ExportResult> {\n    const formatInfo = this.supportedFormats.get(format.toLowerCase());\n\n    if (!formatInfo || !formatInfo.canExport) {\n      throw new Error(`Export not supported for format: ${format}`);\n    }\n\n    try {\n      let result: ExportResult;\n\n      switch (format.toLowerCase()) {\n        case 'kml':\n          result = await this.exportKML(features, filename, options);\n          break;\n        case 'kmz':\n          result = await this.exportKMZ(features, filename, options);\n          break;\n        case 'gpx':\n          result = await this.exportGPX(features, filename, options);\n          break;\n        case 'geojson':\n          result = await this.exportGeoJSON(features, filename, options);\n          break;\n        default:\n          throw new Error(`Export not implemented for ${format}`);\n      }\n\n      this.emit('fileExported', { result, format, filename });\n      return result;\n    } catch (error) {\n      console.error(`Failed to export ${format} file:`, error);\n      this.emit('error', { error, context: 'export', format });\n      throw error;\n    }\n  }\n\n  /**\n   * Convert between formats\n   */\n  async convertFormat(\n    inputUri: string,\n    inputFilename: string,\n    outputFormat: string,\n    outputFilename: string\n  ): Promise<ExportResult> {\n    try {\n      // Import the source file\n      const importResult = await this.importFromFile(inputUri, inputFilename);\n      \n      if (!importResult.success) {\n        throw new Error('Failed to import source file for conversion');\n      }\n\n      // Export to target format\n      return await this.exportFeatures(\n        importResult.features,\n        outputFormat,\n        outputFilename\n      );\n    } catch (error) {\n      console.error('Failed to convert file format:', error);\n      this.emit('error', { error, context: 'conversion' });\n      throw error;\n    }\n  }\n\n  // Private methods for specific formats\n  private async importKML(uri: string, filename: string): Promise<ImportResult> {\n    try {\n      const content = await FileSystem.readAsStringAsync(uri);\n      const kmlDoc = this.parseKML(content);\n      \n      return {\n        success: true,\n        format: 'kml',\n        features: kmlDoc.features,\n        errors: [],\n        warnings: [],\n        metadata: {\n          filename,\n          size: content.length,\n          featureCount: kmlDoc.features.length,\n          bounds: this.calculateBounds(kmlDoc.features),\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        format: 'kml',\n        features: [],\n        errors: [error.message],\n        warnings: [],\n        metadata: {\n          filename,\n          size: 0,\n          featureCount: 0,\n        },\n      };\n    }\n  }\n\n  private async importKMZ(uri: string, filename: string): Promise<ImportResult> {\n    try {\n      const content = await FileSystem.readAsStringAsync(uri, {\n        encoding: FileSystem.EncodingType.Base64,\n      });\n      \n      const zip = new JSZip();\n      const zipContent = await zip.loadAsync(content, { base64: true });\n      \n      // Find the main KML file\n      let kmlContent = '';\n      for (const [filename, file] of Object.entries(zipContent.files)) {\n        if (filename.toLowerCase().endsWith('.kml')) {\n          kmlContent = await file.async('string');\n          break;\n        }\n      }\n      \n      if (!kmlContent) {\n        throw new Error('No KML file found in KMZ archive');\n      }\n      \n      const kmlDoc = this.parseKML(kmlContent);\n      \n      return {\n        success: true,\n        format: 'kmz',\n        features: kmlDoc.features,\n        errors: [],\n        warnings: [],\n        metadata: {\n          filename,\n          size: content.length,\n          featureCount: kmlDoc.features.length,\n          bounds: this.calculateBounds(kmlDoc.features),\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        format: 'kmz',\n        features: [],\n        errors: [error.message],\n        warnings: [],\n        metadata: {\n          filename,\n          size: 0,\n          featureCount: 0,\n        },\n      };\n    }\n  }\n\n  private async importGPX(uri: string, filename: string): Promise<ImportResult> {\n    try {\n      const content = await FileSystem.readAsStringAsync(uri);\n      const features = this.parseGPX(content);\n      \n      return {\n        success: true,\n        format: 'gpx',\n        features,\n        errors: [],\n        warnings: [],\n        metadata: {\n          filename,\n          size: content.length,\n          featureCount: features.length,\n          bounds: this.calculateBounds(features),\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        format: 'gpx',\n        features: [],\n        errors: [error.message],\n        warnings: [],\n        metadata: {\n          filename,\n          size: 0,\n          featureCount: 0,\n        },\n      };\n    }\n  }\n\n  private async importShapefile(uri: string, filename: string): Promise<ImportResult> {\n    try {\n      // Note: Full shapefile support would require additional libraries\n      // This is a simplified implementation\n      throw new Error('Shapefile import requires additional native libraries');\n    } catch (error) {\n      return {\n        success: false,\n        format: 'shp',\n        features: [],\n        errors: [error.message],\n        warnings: ['Shapefile support requires additional setup'],\n        metadata: {\n          filename,\n          size: 0,\n          featureCount: 0,\n        },\n      };\n    }\n  }\n\n  private async exportKML(\n    features: TacticalFeature[],\n    filename: string,\n    options?: any\n  ): Promise<ExportResult> {\n    try {\n      const kmlContent = this.generateKML(features, options);\n      const path = `${FileSystem.documentDirectory}${filename}`;\n      \n      await FileSystem.writeAsStringAsync(path, kmlContent);\n      \n      return {\n        success: true,\n        format: 'kml',\n        filename,\n        size: kmlContent.length,\n        path,\n        errors: [],\n      };\n    } catch (error) {\n      return {\n        success: false,\n        format: 'kml',\n        filename,\n        size: 0,\n        path: '',\n        errors: [error.message],\n      };\n    }\n  }\n\n  private async exportKMZ(\n    features: TacticalFeature[],\n    filename: string,\n    options?: any\n  ): Promise<ExportResult> {\n    try {\n      const kmlContent = this.generateKML(features, options);\n      const zip = new JSZip();\n      \n      zip.file('doc.kml', kmlContent);\n      \n      const zipContent = await zip.generateAsync({ type: 'base64' });\n      const path = `${FileSystem.documentDirectory}${filename}`;\n      \n      await FileSystem.writeAsStringAsync(path, zipContent, {\n        encoding: FileSystem.EncodingType.Base64,\n      });\n      \n      return {\n        success: true,\n        format: 'kmz',\n        filename,\n        size: zipContent.length,\n        path,\n        errors: [],\n      };\n    } catch (error) {\n      return {\n        success: false,\n        format: 'kmz',\n        filename,\n        size: 0,\n        path: '',\n        errors: [error.message],\n      };\n    }\n  }\n\n  private async exportGPX(\n    features: TacticalFeature[],\n    filename: string,\n    options?: any\n  ): Promise<ExportResult> {\n    try {\n      const gpxContent = this.generateGPX(features, options);\n      const path = `${FileSystem.documentDirectory}${filename}`;\n      \n      await FileSystem.writeAsStringAsync(path, gpxContent);\n      \n      return {\n        success: true,\n        format: 'gpx',\n        filename,\n        size: gpxContent.length,\n        path,\n        errors: [],\n      };\n    } catch (error) {\n      return {\n        success: false,\n        format: 'gpx',\n        filename,\n        size: 0,\n        path: '',\n        errors: [error.message],\n      };\n    }\n  }\n\n  private async exportGeoJSON(\n    features: TacticalFeature[],\n    filename: string,\n    options?: any\n  ): Promise<ExportResult> {\n    try {\n      const geoJsonContent = this.generateGeoJSON(features, options);\n      const path = `${FileSystem.documentDirectory}${filename}`;\n      \n      await FileSystem.writeAsStringAsync(path, geoJsonContent);\n      \n      return {\n        success: true,\n        format: 'geojson',\n        filename,\n        size: geoJsonContent.length,\n        path,\n        errors: [],\n      };\n    } catch (error) {\n      return {\n        success: false,\n        format: 'geojson',\n        filename,\n        size: 0,\n        path: '',\n        errors: [error.message],\n      };\n    }\n  }\n\n  // Parsing methods\n  private parseKML(content: string): KMLDocument {\n    // Simplified KML parser - in production, use a proper XML parser\n    const features: TacticalFeature[] = [];\n    \n    // Extract placemarks using regex (simplified approach)\n    const placemarkRegex = /<Placemark[^>]*>([\\s\\S]*?)<\\/Placemark>/gi;\n    let match;\n    \n    while ((match = placemarkRegex.exec(content)) !== null) {\n      const placemarkContent = match[1];\n      const feature = this.parsePlacemark(placemarkContent);\n      if (feature) {\n        features.push(feature);\n      }\n    }\n    \n    return {\n      name: this.extractKMLValue(content, 'name') || 'Imported KML',\n      description: this.extractKMLValue(content, 'description'),\n      features,\n      folders: [],\n      styles: {},\n      metadata: {\n        created: new Date(),\n      },\n    };\n  }\n\n  private parsePlacemark(content: string): TacticalFeature | null {\n    try {\n      const name = this.extractKMLValue(content, 'name') || 'Unnamed';\n      const description = this.extractKMLValue(content, 'description');\n      \n      // Parse coordinates\n      const coordinates = this.extractKMLCoordinates(content);\n      if (!coordinates) {\n        return null;\n      }\n      \n      // Determine geometry type\n      let geometryType: TacticalFeature['geometry']['type'];\n      let featureType: TacticalFeature['type'];\n      \n      if (content.includes('<Point>')) {\n        geometryType = 'Point';\n        featureType = 'point';\n      } else if (content.includes('<LineString>')) {\n        geometryType = 'LineString';\n        featureType = 'line';\n      } else if (content.includes('<Polygon>')) {\n        geometryType = 'Polygon';\n        featureType = 'polygon';\n      } else {\n        geometryType = 'Point';\n        featureType = 'point';\n      }\n      \n      return {\n        id: this.generateFeatureId(),\n        type: featureType,\n        name,\n        description,\n        geometry: {\n          type: geometryType,\n          coordinates,\n        },\n        properties: {\n          timestamp: new Date(),\n        },\n      };\n    } catch (error) {\n      console.error('Failed to parse placemark:', error);\n      return null;\n    }\n  }\n\n  private parseGPX(content: string): TacticalFeature[] {\n    const features: TacticalFeature[] = [];\n    \n    // Parse waypoints\n    const waypointRegex = /<wpt[^>]*lat=\"([^\"]+)\"[^>]*lon=\"([^\"]+)\"[^>]*>([\\s\\S]*?)<\\/wpt>/gi;\n    let match;\n    \n    while ((match = waypointRegex.exec(content)) !== null) {\n      const lat = parseFloat(match[1]);\n      const lng = parseFloat(match[2]);\n      const waypointContent = match[3];\n      const name = this.extractKMLValue(waypointContent, 'name') || 'Waypoint';\n      const description = this.extractKMLValue(waypointContent, 'desc');\n      \n      features.push({\n        id: this.generateFeatureId(),\n        type: 'point',\n        name,\n        description,\n        geometry: {\n          type: 'Point',\n          coordinates: [lng, lat],\n        },\n        properties: {\n          timestamp: new Date(),\n        },\n      });\n    }\n    \n    // Parse tracks\n    const trackRegex = /<trk[^>]*>([\\s\\S]*?)<\\/trk>/gi;\n    while ((match = trackRegex.exec(content)) !== null) {\n      const trackContent = match[1];\n      const name = this.extractKMLValue(trackContent, 'name') || 'Track';\n      const coordinates = this.parseGPXTrackPoints(trackContent);\n      \n      if (coordinates.length > 0) {\n        features.push({\n          id: this.generateFeatureId(),\n          type: 'track',\n          name,\n          geometry: {\n            type: 'LineString',\n            coordinates,\n          },\n          properties: {\n            timestamp: new Date(),\n          },\n        });\n      }\n    }\n    \n    return features;\n  }\n\n  private parseGPXTrackPoints(content: string): number[][] {\n    const coordinates: number[][] = [];\n    const trkptRegex = /<trkpt[^>]*lat=\"([^\"]+)\"[^>]*lon=\"([^\"]+)\"[^>]*>/gi;\n    let match;\n    \n    while ((match = trkptRegex.exec(content)) !== null) {\n      const lat = parseFloat(match[1]);\n      const lng = parseFloat(match[2]);\n      coordinates.push([lng, lat]);\n    }\n    \n    return coordinates;\n  }\n\n  // Generation methods\n  private generateKML(features: TacticalFeature[], options?: any): string {\n    let kml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n    kml += '<kml xmlns=\"http://www.opengis.net/kml/2.2\">\\n';\n    kml += '<Document>\\n';\n    kml += `<name>${options?.name || 'Tactical Export'}</name>\\n`;\n    kml += `<description>${options?.description || 'Exported from Tactical Mapping System'}</description>\\n`;\n    \n    for (const feature of features) {\n      kml += this.generateKMLPlacemark(feature);\n    }\n    \n    kml += '</Document>\\n';\n    kml += '</kml>\\n';\n    \n    return kml;\n  }\n\n  private generateKMLPlacemark(feature: TacticalFeature): string {\n    let placemark = '<Placemark>\\n';\n    placemark += `<name>${this.escapeXML(feature.name)}</name>\\n`;\n    \n    if (feature.description) {\n      placemark += `<description>${this.escapeXML(feature.description)}</description>\\n`;\n    }\n    \n    // Add geometry\n    switch (feature.geometry.type) {\n      case 'Point':\n        const [lng, lat] = feature.geometry.coordinates as number[];\n        placemark += '<Point>\\n';\n        placemark += `<coordinates>${lng},${lat},0</coordinates>\\n`;\n        placemark += '</Point>\\n';\n        break;\n        \n      case 'LineString':\n        placemark += '<LineString>\\n';\n        placemark += '<coordinates>';\n        const lineCoords = feature.geometry.coordinates as number[][];\n        placemark += lineCoords.map(coord => `${coord[0]},${coord[1]},0`).join(' ');\n        placemark += '</coordinates>\\n';\n        placemark += '</LineString>\\n';\n        break;\n        \n      case 'Polygon':\n        placemark += '<Polygon>\\n';\n        placemark += '<outerBoundaryIs>\\n';\n        placemark += '<LinearRing>\\n';\n        placemark += '<coordinates>';\n        const polyCoords = (feature.geometry.coordinates as number[][][])[0];\n        placemark += polyCoords.map(coord => `${coord[0]},${coord[1]},0`).join(' ');\n        placemark += '</coordinates>\\n';\n        placemark += '</LinearRing>\\n';\n        placemark += '</outerBoundaryIs>\\n';\n        placemark += '</Polygon>\\n';\n        break;\n    }\n    \n    placemark += '</Placemark>\\n';\n    return placemark;\n  }\n\n  private generateGPX(features: TacticalFeature[], options?: any): string {\n    let gpx = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n    gpx += '<gpx version=\"1.1\" creator=\"Tactical Mapping System\" xmlns=\"http://www.topografix.com/GPX/1/1\">\\n';\n    gpx += `<metadata>\\n`;\n    gpx += `<name>${options?.name || 'Tactical Export'}</name>\\n`;\n    gpx += `<desc>${options?.description || 'Exported from Tactical Mapping System'}</desc>\\n`;\n    gpx += `<time>${new Date().toISOString()}</time>\\n`;\n    gpx += `</metadata>\\n`;\n    \n    // Add waypoints (points)\n    for (const feature of features) {\n      if (feature.type === 'point' && feature.geometry.type === 'Point') {\n        const [lng, lat] = feature.geometry.coordinates as number[];\n        gpx += `<wpt lat=\"${lat}\" lon=\"${lng}\">\\n`;\n        gpx += `<name>${this.escapeXML(feature.name)}</name>\\n`;\n        if (feature.description) {\n          gpx += `<desc>${this.escapeXML(feature.description)}</desc>\\n`;\n        }\n        gpx += `</wpt>\\n`;\n      }\n    }\n    \n    // Add tracks (lines)\n    for (const feature of features) {\n      if ((feature.type === 'line' || feature.type === 'track') && feature.geometry.type === 'LineString') {\n        gpx += `<trk>\\n`;\n        gpx += `<name>${this.escapeXML(feature.name)}</name>\\n`;\n        if (feature.description) {\n          gpx += `<desc>${this.escapeXML(feature.description)}</desc>\\n`;\n        }\n        gpx += `<trkseg>\\n`;\n        \n        const coordinates = feature.geometry.coordinates as number[][];\n        for (const [lng, lat] of coordinates) {\n          gpx += `<trkpt lat=\"${lat}\" lon=\"${lng}\"></trkpt>\\n`;\n        }\n        \n        gpx += `</trkseg>\\n`;\n        gpx += `</trk>\\n`;\n      }\n    }\n    \n    gpx += '</gpx>\\n';\n    return gpx;\n  }\n\n  private generateGeoJSON(features: TacticalFeature[], options?: any): string {\n    const geoJson = {\n      type: 'FeatureCollection',\n      features: features.map(feature => ({\n        type: 'Feature',\n        id: feature.id,\n        geometry: feature.geometry,\n        properties: {\n          name: feature.name,\n          description: feature.description,\n          ...feature.properties,\n        },\n      })),\n    };\n    \n    return JSON.stringify(geoJson, null, 2);\n  }\n\n  // Utility methods\n  private initializeSupportedFormats(): void {\n    const formats: FileFormatSupport[] = [\n      {\n        extension: 'kml',\n        mimeType: 'application/vnd.google-earth.kml+xml',\n        name: 'Keyhole Markup Language',\n        description: 'Google Earth KML format for geographic data',\n        canImport: true,\n        canExport: true,\n        features: ['points', 'lines', 'polygons', 'styles', 'folders'],\n      },\n      {\n        extension: 'kmz',\n        mimeType: 'application/vnd.google-earth.kmz',\n        name: 'Compressed KML',\n        description: 'Compressed KML format with embedded resources',\n        canImport: true,\n        canExport: true,\n        features: ['points', 'lines', 'polygons', 'styles', 'images'],\n      },\n      {\n        extension: 'gpx',\n        mimeType: 'application/gpx+xml',\n        name: 'GPS Exchange Format',\n        description: 'Standard format for GPS data exchange',\n        canImport: true,\n        canExport: true,\n        features: ['waypoints', 'tracks', 'routes', 'metadata'],\n      },\n      {\n        extension: 'geojson',\n        mimeType: 'application/geo+json',\n        name: 'GeoJSON',\n        description: 'JSON format for geographic data structures',\n        canImport: true,\n        canExport: true,\n        features: ['points', 'lines', 'polygons', 'properties'],\n      },\n      {\n        extension: 'shp',\n        mimeType: 'application/x-shapefile',\n        name: 'Shapefile',\n        description: 'ESRI Shapefile format for vector data',\n        canImport: false, // Requires additional libraries\n        canExport: false,\n        features: ['points', 'lines', 'polygons', 'attributes'],\n      },\n    ];\n    \n    formats.forEach(format => {\n      this.supportedFormats.set(format.extension, format);\n    });\n  }\n\n  private getFileExtension(filename: string): string {\n    return filename.toLowerCase().split('.').pop() || '';\n  }\n\n  private extractKMLValue(content: string, tagName: string): string | null {\n    const regex = new RegExp(`<${tagName}[^>]*>([\\\\s\\\\S]*?)<\\/${tagName}>`, 'i');\n    const match = content.match(regex);\n    return match ? match[1].trim() : null;\n  }\n\n  private extractKMLCoordinates(content: string): number[] | number[][] | number[][][] | null {\n    const coordsMatch = content.match(/<coordinates[^>]*>([\\s\\S]*?)<\\/coordinates>/i);\n    if (!coordsMatch) {\n      return null;\n    }\n    \n    const coordsText = coordsMatch[1].trim();\n    const coordPairs = coordsText.split(/\\s+/);\n    \n    if (coordPairs.length === 1) {\n      // Single point\n      const [lng, lat, alt] = coordPairs[0].split(',').map(Number);\n      return [lng, lat];\n    } else {\n      // Multiple points (line or polygon)\n      return coordPairs.map(pair => {\n        const [lng, lat, alt] = pair.split(',').map(Number);\n        return [lng, lat];\n      });\n    }\n  }\n\n  private calculateBounds(features: TacticalFeature[]): { north: number; south: number; east: number; west: number } | undefined {\n    if (features.length === 0) {\n      return undefined;\n    }\n    \n    let north = -90, south = 90, east = -180, west = 180;\n    \n    for (const feature of features) {\n      const coords = this.extractCoordinatesFromGeometry(feature.geometry);\n      \n      for (const [lng, lat] of coords) {\n        north = Math.max(north, lat);\n        south = Math.min(south, lat);\n        east = Math.max(east, lng);\n        west = Math.min(west, lng);\n      }\n    }\n    \n    return { north, south, east, west };\n  }\n\n  private extractCoordinatesFromGeometry(geometry: TacticalFeature['geometry']): number[][] {\n    switch (geometry.type) {\n      case 'Point':\n        return [geometry.coordinates as number[]];\n      case 'LineString':\n      case 'MultiPoint':\n        return geometry.coordinates as number[][];\n      case 'Polygon':\n      case 'MultiLineString':\n        return (geometry.coordinates as number[][][]).flat();\n      case 'MultiPolygon':\n        return (geometry.coordinates as number[][][][]).flat(2);\n      default:\n        return [];\n    }\n  }\n\n  private escapeXML(text: string): string {\n    return text\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&apos;');\n  }\n\n  private generateFeatureId(): string {\n    return `feature_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Cleanup resources\n   */\n  async cleanup(): Promise<void> {\n    this.supportedFormats.clear();\n    this.removeAllListeners();\n    this.initialized = false;\n  }\n}\n\n// Singleton instance\nlet fileFormatServiceInstance: FileFormatService | null = null;\n\nexport const getFileFormatService = (): FileFormatService => {\n  if (!fileFormatServiceInstance) {\n    fileFormatServiceInstance = new FileFormatService();\n  }\n  \n  return fileFormatServiceInstance;\n};\n\nexport default FileFormatService;"