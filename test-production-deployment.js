#!/usr/bin/env node
/**\n * TacticalOps Platform - Production Deployment Testing Suite\n * Comprehensive testing for production deployment with PostgreSQL + PostGIS + MinIO\n */\n\nconst axios = require('axios');\nconst fs = require('fs').promises;\nconst path = require('path');\nconst { execSync } = require('child_process');\n\n// Test configuration\nconst CONFIG = {\n  baseURL: process.env.TEST_BASE_URL || 'https://ta.consulting.sa',\n  timeout: 30000,\n  retries: 3,\n  testData: {\n    admin: {\n      username: 'admin',\n      password: 'admin123'\n    },\n    testUser: {\n      username: 'testuser',\n      email: 'test@tacticalops.local',\n      password: 'testpass123'\n    }\n  }\n};\n\n// Colors for console output\nconst colors = {\n  reset: '\\x1b[0m',\n  red: '\\x1b[31m',\n  green: '\\x1b[32m',\n  yellow: '\\x1b[33m',\n  blue: '\\x1b[34m',\n  magenta: '\\x1b[35m',\n  cyan: '\\x1b[36m'\n};\n\n// Logging functions\nconst log = (message, color = colors.blue) => {\n  console.log(`${color}[${new Date().toISOString()}] ${message}${colors.reset}`);\n};\n\nconst success = (message) => log(`‚úÖ ${message}`, colors.green);\nconst error = (message) => log(`‚ùå ${message}`, colors.red);\nconst warn = (message) => log(`‚ö†Ô∏è ${message}`, colors.yellow);\nconst info = (message) => log(`‚ÑπÔ∏è ${message}`, colors.cyan);\n\n// Test results tracking\nconst testResults = {\n  total: 0,\n  passed: 0,\n  failed: 0,\n  skipped: 0,\n  details: []\n};\n\n// HTTP client setup\nconst httpClient = axios.create({\n  baseURL: CONFIG.baseURL,\n  timeout: CONFIG.timeout,\n  headers: {\n    'Content-Type': 'application/json',\n    'User-Agent': 'TacticalOps-Production-Test-Suite/2.0.0'\n  },\n  validateStatus: () => true // Don't throw on HTTP errors\n});\n\n// Test execution wrapper\nconst runTest = async (testName, testFunction) => {\n  testResults.total++;\n  \n  try {\n    log(`üß™ Running test: ${testName}`, colors.magenta);\n    const startTime = Date.now();\n    \n    await testFunction();\n    \n    const duration = Date.now() - startTime;\n    testResults.passed++;\n    testResults.details.push({\n      name: testName,\n      status: 'PASSED',\n      duration,\n      error: null\n    });\n    \n    success(`${testName} (${duration}ms)`);\n  } catch (err) {\n    testResults.failed++;\n    testResults.details.push({\n      name: testName,\n      status: 'FAILED',\n      duration: 0,\n      error: err.message\n    });\n    \n    error(`${testName}: ${err.message}`);\n  }\n};\n\n// Basic connectivity tests\nconst testBasicConnectivity = async () => {\n  const response = await httpClient.get('/health');\n  \n  if (response.status !== 200) {\n    throw new Error(`Health check failed with status: ${response.status}`);\n  }\n  \n  if (!response.data.success) {\n    throw new Error('Health check returned unsuccessful response');\n  }\n  \n  info('Basic connectivity established');\n};\n\n// SSL/TLS certificate test\nconst testSSLCertificate = async () => {\n  const response = await httpClient.get('/health');\n  \n  if (!CONFIG.baseURL.startsWith('https://')) {\n    throw new Error('HTTPS is not configured');\n  }\n  \n  // Check if we can make HTTPS requests without errors\n  if (response.status !== 200) {\n    throw new Error('HTTPS connection failed');\n  }\n  \n  info('SSL/TLS certificate is working');\n};\n\n// API endpoints test\nconst testAPIEndpoints = async () => {\n  const endpoints = [\n    { path: '/api/v2/health', expectedStatus: 200 },\n    { path: '/api/v2/status', expectedStatus: [200, 401] }, // May require auth\n    { path: '/api/auth/login', expectedStatus: [200, 400, 405] }, // POST endpoint\n    { path: '/robots.txt', expectedStatus: 200 },\n    { path: '/.well-known/security.txt', expectedStatus: 200 }\n  ];\n  \n  for (const endpoint of endpoints) {\n    const response = await httpClient.get(endpoint.path);\n    const expectedStatuses = Array.isArray(endpoint.expectedStatus) \n      ? endpoint.expectedStatus \n      : [endpoint.expectedStatus];\n    \n    if (!expectedStatuses.includes(response.status)) {\n      throw new Error(`Endpoint ${endpoint.path} returned status ${response.status}, expected ${endpoint.expectedStatus}`);\n    }\n    \n    info(`Endpoint ${endpoint.path}: ${response.status}`);\n  }\n};\n\n// Database connectivity test\nconst testDatabaseConnectivity = async () => {\n  const response = await httpClient.get('/api/v2/health');\n  \n  if (response.status !== 200) {\n    throw new Error('Cannot reach health endpoint');\n  }\n  \n  const healthData = response.data.data;\n  \n  if (!healthData.database || healthData.database.status !== 'connected') {\n    throw new Error('Database is not connected');\n  }\n  \n  if (!healthData.database.postgis) {\n    throw new Error('PostGIS extension is not available');\n  }\n  \n  info(`Database: ${healthData.database.type} with PostGIS ${healthData.database.postgis}`);\n};\n\n// Redis connectivity test\nconst testRedisConnectivity = async () => {\n  const response = await httpClient.get('/api/v2/health');\n  \n  if (response.status !== 200) {\n    throw new Error('Cannot reach health endpoint');\n  }\n  \n  const healthData = response.data.data;\n  \n  if (!healthData.redis || healthData.redis.status !== 'connected') {\n    throw new Error('Redis is not connected');\n  }\n  \n  info(`Redis: ${healthData.redis.version}`);\n};\n\n// MinIO S3 storage test\nconst testMinIOStorage = async () => {\n  const response = await httpClient.get('/api/v2/health');\n  \n  if (response.status !== 200) {\n    throw new Error('Cannot reach health endpoint');\n  }\n  \n  const healthData = response.data.data;\n  \n  if (!healthData.storage || healthData.storage.status !== 'connected') {\n    throw new Error('MinIO storage is not connected');\n  }\n  \n  if (!healthData.storage.buckets || healthData.storage.buckets.length === 0) {\n    throw new Error('No storage buckets are configured');\n  }\n  \n  info(`MinIO Storage: ${healthData.storage.buckets.length} buckets configured`);\n};\n\n// Authentication system test\nconst testAuthenticationSystem = async () => {\n  // Test login endpoint\n  const loginResponse = await httpClient.post('/api/auth/login', {\n    username: CONFIG.testData.admin.username,\n    password: CONFIG.testData.admin.password\n  });\n  \n  if (loginResponse.status !== 200) {\n    throw new Error(`Login failed with status: ${loginResponse.status}`);\n  }\n  \n  if (!loginResponse.data.success || !loginResponse.data.data.token) {\n    throw new Error('Login did not return a valid token');\n  }\n  \n  const token = loginResponse.data.data.token;\n  \n  // Test authenticated endpoint\n  const profileResponse = await httpClient.get('/api/user/profile', {\n    headers: {\n      'Authorization': `Bearer ${token}`\n    }\n  });\n  \n  if (profileResponse.status !== 200) {\n    throw new Error(`Profile endpoint failed with status: ${profileResponse.status}`);\n  }\n  \n  info('Authentication system is working');\n  return token;\n};\n\n// Geospatial features test\nconst testGeospatialFeatures = async (authToken) => {\n  // Test location update\n  const locationResponse = await httpClient.post('/api/location/sync', {\n    latitude: 24.7136,\n    longitude: 46.6753,\n    accuracy: 10,\n    timestamp: new Date().toISOString()\n  }, {\n    headers: {\n      'Authorization': `Bearer ${authToken}`\n    }\n  });\n  \n  if (locationResponse.status !== 200) {\n    throw new Error(`Location sync failed with status: ${locationResponse.status}`);\n  }\n  \n  // Test geofence check\n  const geofenceResponse = await httpClient.get('/api/geofence/check', {\n    params: {\n      latitude: 24.7136,\n      longitude: 46.6753\n    },\n    headers: {\n      'Authorization': `Bearer ${authToken}`\n    }\n  });\n  \n  if (geofenceResponse.status !== 200) {\n    warn('Geofence check endpoint may not be implemented yet');\n  } else {\n    info('Geospatial features are working');\n  }\n};\n\n// Emergency alert system test\nconst testEmergencyAlertSystem = async (authToken) => {\n  // Test emergency alert creation\n  const alertResponse = await httpClient.post('/api/emergency/alert', {\n    type: 'test',\n    severity: 'low',\n    title: 'Test Alert',\n    description: 'This is a test alert for deployment validation',\n    location: {\n      latitude: 24.7136,\n      longitude: 46.6753\n    }\n  }, {\n    headers: {\n      'Authorization': `Bearer ${authToken}`\n    }\n  });\n  \n  if (alertResponse.status !== 200 && alertResponse.status !== 201) {\n    throw new Error(`Emergency alert creation failed with status: ${alertResponse.status}`);\n  }\n  \n  info('Emergency alert system is working');\n};\n\n// Agent API test\nconst testAgentAPI = async () => {\n  // Test agent authentication\n  const agentAuthResponse = await httpClient.post('/api/agent/auth', {\n    agentId: 'test-agent-001',\n    capabilities: ['system-monitoring', 'user-assistance']\n  }, {\n    headers: {\n      'X-API-Key': process.env.AGENT_API_KEY || 'TacticalOps2024AgentAPIKey32CharactersSecure!'\n    }\n  });\n  \n  if (agentAuthResponse.status !== 200) {\n    throw new Error(`Agent authentication failed with status: ${agentAuthResponse.status}`);\n  }\n  \n  if (!agentAuthResponse.data.success || !agentAuthResponse.data.data.token) {\n    throw new Error('Agent authentication did not return a valid token');\n  }\n  \n  const agentToken = agentAuthResponse.data.data.token;\n  \n  // Test agent system monitoring\n  const systemResponse = await httpClient.get('/api/agent/system', {\n    headers: {\n      'Authorization': `Bearer ${agentToken}`\n    }\n  });\n  \n  if (systemResponse.status !== 200) {\n    throw new Error(`Agent system monitoring failed with status: ${systemResponse.status}`);\n  }\n  \n  info('Agent API is working');\n};\n\n// LLM integration test\nconst testLLMIntegration = async () => {\n  // Test agent authentication first\n  const agentAuthResponse = await httpClient.post('/api/agent/auth', {\n    agentId: 'llm-test-agent',\n    capabilities: ['user-assistance', 'system-monitoring']\n  }, {\n    headers: {\n      'X-API-Key': process.env.AGENT_API_KEY || 'TacticalOps2024AgentAPIKey32CharactersSecure!'\n    }\n  });\n  \n  if (agentAuthResponse.status !== 200) {\n    throw new Error('Agent authentication required for LLM testing');\n  }\n  \n  const agentToken = agentAuthResponse.data.data.token;\n  \n  // Test LLM health check\n  const llmHealthResponse = await httpClient.get('/api/agent/llm?type=health', {\n    headers: {\n      'Authorization': `Bearer ${agentToken}`\n    }\n  });\n  \n  if (llmHealthResponse.status !== 200) {\n    warn('LLM integration may not be configured or enabled');\n    return;\n  }\n  \n  const llmHealth = llmHealthResponse.data.data.llmService;\n  if (llmHealth.status !== 'healthy') {\n    throw new Error(`LLM service is ${llmHealth.status}`);\n  }\n  \n  // Test simple LLM query\n  const llmQueryResponse = await httpClient.post('/api/agent/llm', {\n    action: 'query',\n    query: 'What is the current system status?',\n    agentType: 'system-monitoring'\n  }, {\n    headers: {\n      'Authorization': `Bearer ${agentToken}`\n    }\n  });\n  \n  if (llmQueryResponse.status !== 200) {\n    throw new Error(`LLM query failed with status: ${llmQueryResponse.status}`);\n  }\n  \n  const queryResult = llmQueryResponse.data.data.response;\n  if (!queryResult.content || queryResult.confidence < 0.5) {\n    throw new Error(`LLM response quality is poor: confidence ${queryResult.confidence}`);\n  }\n  \n  info(`LLM Integration: Model ${llmHealth.model}, Latency ${llmHealth.latency}ms, Confidence ${queryResult.confidence}`);\n};\n\n// Performance test\nconst testPerformance = async () => {\n  const startTime = Date.now();\n  const requests = [];\n  \n  // Make 10 concurrent requests to health endpoint\n  for (let i = 0; i < 10; i++) {\n    requests.push(httpClient.get('/health'));\n  }\n  \n  const responses = await Promise.all(requests);\n  const endTime = Date.now();\n  \n  const totalTime = endTime - startTime;\n  const avgTime = totalTime / responses.length;\n  \n  // Check if all requests succeeded\n  const failedRequests = responses.filter(r => r.status !== 200).length;\n  if (failedRequests > 0) {\n    throw new Error(`${failedRequests} out of ${responses.length} requests failed`);\n  }\n  \n  // Check if average response time is acceptable\n  if (avgTime > 2000) {\n    throw new Error(`Average response time ${avgTime}ms exceeds 2000ms threshold`);\n  }\n  \n  info(`Performance: ${responses.length} requests in ${totalTime}ms (avg: ${avgTime.toFixed(2)}ms)`);\n};\n\n// Security headers test\nconst testSecurityHeaders = async () => {\n  const response = await httpClient.get('/');\n  \n  const requiredHeaders = [\n    'x-frame-options',\n    'x-content-type-options',\n    'x-xss-protection',\n    'strict-transport-security'\n  ];\n  \n  const missingHeaders = [];\n  \n  for (const header of requiredHeaders) {\n    if (!response.headers[header]) {\n      missingHeaders.push(header);\n    }\n  }\n  \n  if (missingHeaders.length > 0) {\n    throw new Error(`Missing security headers: ${missingHeaders.join(', ')}`);\n  }\n  \n  info('Security headers are properly configured');\n};\n\n// Monitoring endpoints test\nconst testMonitoringEndpoints = async () => {\n  // Test Grafana (should be restricted)\n  const grafanaResponse = await httpClient.get('/grafana/');\n  \n  // Should either be accessible (if from allowed IP) or forbidden\n  if (grafanaResponse.status !== 200 && grafanaResponse.status !== 403 && grafanaResponse.status !== 404) {\n    warn(`Grafana endpoint returned unexpected status: ${grafanaResponse.status}`);\n  } else {\n    info('Grafana endpoint is properly configured');\n  }\n  \n  // Test MinIO console (should be restricted)\n  const minioResponse = await httpClient.get('/minio/');\n  \n  // Should either be accessible (if from allowed IP) or forbidden\n  if (minioResponse.status !== 200 && minioResponse.status !== 403 && minioResponse.status !== 404) {\n    warn(`MinIO console endpoint returned unexpected status: ${minioResponse.status}`);\n  } else {\n    info('MinIO console endpoint is properly configured');\n  }\n};\n\n// Generate test report\nconst generateTestReport = async () => {\n  const report = {\n    timestamp: new Date().toISOString(),\n    environment: {\n      baseURL: CONFIG.baseURL,\n      nodeVersion: process.version,\n      platform: process.platform\n    },\n    summary: {\n      total: testResults.total,\n      passed: testResults.passed,\n      failed: testResults.failed,\n      skipped: testResults.skipped,\n      successRate: ((testResults.passed / testResults.total) * 100).toFixed(2) + '%'\n    },\n    details: testResults.details\n  };\n  \n  // Write report to file\n  const reportPath = path.join(__dirname, 'production-test-report.json');\n  await fs.writeFile(reportPath, JSON.stringify(report, null, 2));\n  \n  // Generate HTML report\n  const htmlReport = `\n<!DOCTYPE html>\n<html>\n<head>\n    <title>TacticalOps Production Test Report</title>\n    <style>\n        body { font-family: Arial, sans-serif; margin: 20px; }\n        .header { background: #f0f0f0; padding: 20px; border-radius: 5px; }\n        .summary { display: flex; gap: 20px; margin: 20px 0; }\n        .metric { background: #e8f4f8; padding: 15px; border-radius: 5px; text-align: center; }\n        .passed { background: #d4edda; }\n        .failed { background: #f8d7da; }\n        .test-details { margin-top: 20px; }\n        .test-item { margin: 10px 0; padding: 10px; border-left: 4px solid #ccc; }\n        .test-passed { border-left-color: #28a745; }\n        .test-failed { border-left-color: #dc3545; }\n    </style>\n</head>\n<body>\n    <div class=\"header\">\n        <h1>üéñÔ∏è TacticalOps Production Test Report</h1>\n        <p><strong>Environment:</strong> ${CONFIG.baseURL}</p>\n        <p><strong>Test Date:</strong> ${new Date().toLocaleString()}</p>\n    </div>\n    \n    <div class=\"summary\">\n        <div class=\"metric\">\n            <h3>${testResults.total}</h3>\n            <p>Total Tests</p>\n        </div>\n        <div class=\"metric passed\">\n            <h3>${testResults.passed}</h3>\n            <p>Passed</p>\n        </div>\n        <div class=\"metric failed\">\n            <h3>${testResults.failed}</h3>\n            <p>Failed</p>\n        </div>\n        <div class=\"metric\">\n            <h3>${report.summary.successRate}</h3>\n            <p>Success Rate</p>\n        </div>\n    </div>\n    \n    <div class=\"test-details\">\n        <h2>Test Details</h2>\n        ${testResults.details.map(test => `\n            <div class=\"test-item test-${test.status.toLowerCase()}\">\n                <h4>${test.name}</h4>\n                <p><strong>Status:</strong> ${test.status}</p>\n                ${test.duration > 0 ? `<p><strong>Duration:</strong> ${test.duration}ms</p>` : ''}\n                ${test.error ? `<p><strong>Error:</strong> ${test.error}</p>` : ''}\n            </div>\n        `).join('')}\n    </div>\n</body>\n</html>\n  `;\n  \n  const htmlReportPath = path.join(__dirname, 'production-test-report.html');\n  await fs.writeFile(htmlReportPath, htmlReport);\n  \n  info(`Test report generated: ${reportPath}`);\n  info(`HTML report generated: ${htmlReportPath}`);\n};\n\n// Main test execution\nconst main = async () => {\n  log('üéñÔ∏è TacticalOps Production Deployment Test Suite', colors.magenta);\n  log('================================================', colors.magenta);\n  log(`Testing environment: ${CONFIG.baseURL}`);\n  log('');\n  \n  // Core functionality tests\n  await runTest('Basic Connectivity', testBasicConnectivity);\n  await runTest('SSL/TLS Certificate', testSSLCertificate);\n  await runTest('API Endpoints', testAPIEndpoints);\n  await runTest('Security Headers', testSecurityHeaders);\n  \n  // Infrastructure tests\n  await runTest('Database Connectivity (PostgreSQL + PostGIS)', testDatabaseConnectivity);\n  await runTest('Redis Connectivity', testRedisConnectivity);\n  await runTest('MinIO S3 Storage', testMinIOStorage);\n  \n  // Application functionality tests\n  let authToken;\n  await runTest('Authentication System', async () => {\n    authToken = await testAuthenticationSystem();\n  });\n  \n  if (authToken) {\n    await runTest('Geospatial Features', () => testGeospatialFeatures(authToken));\n    await runTest('Emergency Alert System', () => testEmergencyAlertSystem(authToken));\n  }\n  \n  // Advanced features tests\n  await runTest('Agent API', testAgentAPI);\n  await runTest('LLM Integration', testLLMIntegration);\n  \n  // Performance and monitoring tests\n  await runTest('Performance', testPerformance);\n  await runTest('Monitoring Endpoints', testMonitoringEndpoints);\n  \n  // Generate test report\n  await generateTestReport();\n  \n  // Final summary\n  log('');\n  log('üìä Test Summary', colors.magenta);\n  log('===============', colors.magenta);\n  log(`Total Tests: ${testResults.total}`);\n  success(`Passed: ${testResults.passed}`);\n  if (testResults.failed > 0) {\n    error(`Failed: ${testResults.failed}`);\n  }\n  if (testResults.skipped > 0) {\n    warn(`Skipped: ${testResults.skipped}`);\n  }\n  \n  const successRate = ((testResults.passed / testResults.total) * 100).toFixed(2);\n  log(`Success Rate: ${successRate}%`);\n  \n  if (testResults.failed === 0) {\n    success('üéâ All tests passed! Production deployment is ready.');\n    process.exit(0);\n  } else {\n    error('‚ùå Some tests failed. Please review the issues before going live.');\n    process.exit(1);\n  }\n};\n\n// Handle unhandled promise rejections\nprocess.on('unhandledRejection', (reason, promise) => {\n  error(`Unhandled Rejection at: ${promise}, reason: ${reason}`);\n  process.exit(1);\n});\n\n// Execute main function\nif (require.main === module) {\n  main().catch(err => {\n    error(`Test suite failed: ${err.message}`);\n    process.exit(1);\n  });\n}\n\nmodule.exports = { main, runTest };